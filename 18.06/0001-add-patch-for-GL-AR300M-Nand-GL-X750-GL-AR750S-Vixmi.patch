From 515580e76044b94a0129592dddaf8359a9a05a22 Mon Sep 17 00:00:00 2001
From: Alfie Zhao <alzhao@gmail.com>
Date: Mon, 24 Sep 2018 12:46:18 +0800
Subject: [PATCH] add patch for GL-AR300M-Nand, GL-X750, GL-AR750S, Vixmini

---
 target/linux/ar71xx/base-files/etc/board.d/01_leds |   12 +-
 .../linux/ar71xx/base-files/etc/board.d/02_network |    5 +
 target/linux/ar71xx/base-files/etc/diag.sh         |    7 +-
 .../etc/hotplug.d/firmware/11-ath10k-caldata       |    2 +
 target/linux/ar71xx/base-files/lib/ar71xx.sh       |    6 +
 .../ar71xx/base-files/lib/upgrade/platform.sh      |   52 +-
 target/linux/ar71xx/config-4.9                     |    2 +
 .../ar71xx/files/arch/mips/ath79/Kconfig.openwrt   |   22 +
 target/linux/ar71xx/files/arch/mips/ath79/Makefile |    2 +
 .../ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c  |    3 +-
 .../ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c  |  202 ++
 .../ar71xx/files/arch/mips/ath79/mach-gl-mifi.c    |    6 +
 .../ar71xx/files/arch/mips/ath79/mach-gl-usb150.c  |    1 +
 .../ar71xx/files/arch/mips/ath79/mach-gl-x750-4g.c |  176 ++
 .../linux/ar71xx/files/arch/mips/ath79/machtypes.h |    2 +
 target/linux/ar71xx/generic/config-default         |    2 +
 target/linux/ar71xx/image/generic.mk               |   26 +
 target/linux/ar71xx/image/legacy.mk                |   33 +
 target/linux/ar71xx/image/nand.mk                  |   21 +
 target/linux/ar71xx/image/ubinize-gl-ar300m.ini    |   26 +
 target/linux/ar71xx/image/ubinize-gl-ar750s.ini    |   26 +
 target/linux/ar71xx/image/ubinize-gl-x750-4g.ini   |   26 +
 target/linux/ar71xx/nand/config-default            |    4 +
 .../patches-4.9/491-mtd-spi-nand-driver.patch      | 2785 ++++++++++++++++++++
 .../ar71xx/patches-4.9/742-add-modem-driver.patch  |  250 ++
 .../patches-4.9/821-add-QCA8337-PHY-reset.patch    |   37 +
 .../patches-4.9/931-support-fast-forward.patch     |  100 +
 ...eless_compatible_with_deprecated_wext_api.patch |   15 +
 target/linux/ramips/base-files/etc/board.d/01_leds |    3 +
 .../linux/ramips/base-files/etc/board.d/02_network |    3 +
 target/linux/ramips/base-files/etc/diag.sh         |    3 -
 target/linux/ramips/base-files/lib/ramips.sh       |    3 +
 .../ramips/base-files/lib/upgrade/platform.sh      |    1 +
 target/linux/ramips/dts/VIXMINI.dts                |  106 +
 target/linux/ramips/image/mt76x8.mk                |    7 +
 target/linux/ramips/mt7620/config-4.14             |    3 +-
 target/linux/ramips/mt76x8/config-4.4              |  206 ++
 37 files changed, 4171 insertions(+), 15 deletions(-)
 create mode 100755 target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c
 create mode 100644 target/linux/ar71xx/files/arch/mips/ath79/mach-gl-x750-4g.c
 create mode 100644 target/linux/ar71xx/image/ubinize-gl-ar300m.ini
 create mode 100644 target/linux/ar71xx/image/ubinize-gl-ar750s.ini
 create mode 100644 target/linux/ar71xx/image/ubinize-gl-x750-4g.ini
 create mode 100644 target/linux/ar71xx/patches-4.9/491-mtd-spi-nand-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.9/742-add-modem-driver.patch
 create mode 100644 target/linux/ar71xx/patches-4.9/821-add-QCA8337-PHY-reset.patch
 create mode 100644 target/linux/ar71xx/patches-4.9/931-support-fast-forward.patch
 create mode 100644 target/linux/generic/hack-4.14/801-wireless_compatible_with_deprecated_wext_api.patch
 create mode 100644 target/linux/ramips/dts/VIXMINI.dts
 create mode 100644 target/linux/ramips/mt76x8/config-4.4

diff --git a/target/linux/ar71xx/base-files/etc/board.d/01_leds b/target/linux/ar71xx/base-files/etc/board.d/01_leds
index 858d675..67f1ec0 100755
--- a/target/linux/ar71xx/base-files/etc/board.d/01_leds
+++ b/target/linux/ar71xx/base-files/etc/board.d/01_leds
@@ -90,7 +90,6 @@ e750a-v4)
 	esac
 	;;
 ap531b0|\
-gl-usb150|\
 sc1750|\
 sc450)
 	ucidef_set_led_wlan "wlan" "WLAN" "$board:green:wlan" "phy0tpt"
@@ -395,9 +394,20 @@ fritz450e)
 	ucidef_set_led_netdev "lan" "LAN" "$board:green:lan" "eth0"
 	ucidef_set_led_wlan "wlan" "WLAN" "$board:green:wlan" "phy0tpt"
 	;;
+gl-usb150)
+	ucidef_set_led_wlan "wlan" "WLAN" "$board:green:wlan" "phy0tpt"
+	ucidef_set_led_default "power" "POWER" "$board:green:power" "1"
+	;;
 gl-ar300m)
 	ucidef_set_led_wlan "wlan" "WLAN" "$board:red:wlan" "phy0tpt"
 	;;
+gl-x750-4g)
+	ucidef_set_led_wlan "wlan2g" "WLAN2G" "$board:white:wlan2g" "phy1tpt"
+	ucidef_set_led_wlan "wlan5g" "WLAN5G" "$board:white:wlan5g" "phy0tpt"
+	ucidef_set_led_netdev "wan" "WAN" "$board:white:wan" "eth0"
+	ucidef_set_led_netdev  "3gnet" "3GNET" "$board:white:4g" "3g-wan"
+	;;
+gl-ar750s|\
 gl-ar750)
 	ucidef_set_led_wlan "wlan2g" "WLAN2G" "$board:white:wlan2g" "phy1tpt"
 	ucidef_set_led_wlan "wlan5g" "WLAN5G" "$board:white:wlan5g" "phy0tpt"
diff --git a/target/linux/ar71xx/base-files/etc/board.d/02_network b/target/linux/ar71xx/base-files/etc/board.d/02_network
index b007636..4398a70 100755
--- a/target/linux/ar71xx/base-files/etc/board.d/02_network
+++ b/target/linux/ar71xx/base-files/etc/board.d/02_network
@@ -160,6 +160,7 @@ ar71xx_setup_interfaces()
 	dr344|\
 	gl-ar150|\
 	gl-ar300m|\
+	gl-x750-4g|\
 	gl-domino|\
 	gl-inet|\
 	gl-mifi|\
@@ -179,6 +180,10 @@ ar71xx_setup_interfaces()
 	wrtnode2q)
 		ucidef_set_interfaces_lan_wan "eth1" "eth0"
 		;;
+	gl-ar750s)
+		ucidef_add_switch "switch0" \
+ 			"0@eth0" "2:lan:2" "3:lan:1" "1:wan"
+		;;
 	rb-750-r2|\
 	rb-750p-pbr2|\
 	rb-750up-r2|\
diff --git a/target/linux/ar71xx/base-files/etc/diag.sh b/target/linux/ar71xx/base-files/etc/diag.sh
index 4eb2abb..0b94f99 100644
--- a/target/linux/ar71xx/base-files/etc/diag.sh
+++ b/target/linux/ar71xx/base-files/etc/diag.sh
@@ -73,7 +73,6 @@ get_status_led() {
 	fritz300e|\
 	fritz4020|\
 	fritz450e|\
-	gl-usb150|\
 	mr12|\
 	mr16|\
 	nbg6616|\
@@ -102,10 +101,7 @@ get_status_led() {
 		;;
 	ap90q|\
 	cpe830|\
-	cpe870|\
-	gl-ar300m|\
-	gl-inet|\
-	gl-mifi)
+	cpe870)
 		status_led="$board:green:lan"
 		;;
 	ap91-5g|\
@@ -246,7 +242,6 @@ get_status_led() {
 	esr1750)
 		status_led="$board:amber:power"
 		;;
-	gl-ar750|\
 	hiveap-121|\
 	nbg6716|\
 	wam250)
diff --git a/target/linux/ar71xx/base-files/etc/hotplug.d/firmware/11-ath10k-caldata b/target/linux/ar71xx/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
index 53f5377..3daa77f 100644
--- a/target/linux/ar71xx/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
+++ b/target/linux/ar71xx/base-files/etc/hotplug.d/firmware/11-ath10k-caldata
@@ -100,6 +100,8 @@ case "$FIRMWARE" in
 		ath10kcal_extract "caldata" 20480 2116
 		ath10kcal_patch_mac $(macaddr_add $(cat /sys/class/net/eth0/address) +1)
 		;;
+	gl-x750-4g|\
+	gl-ar750s|\
 	gl-ar750|\
 	tl-wpa8630)
 		ath10kcal_extract "art" 20480 2116
diff --git a/target/linux/ar71xx/base-files/lib/ar71xx.sh b/target/linux/ar71xx/base-files/lib/ar71xx.sh
index 3af2eee..c89d048 100755
--- a/target/linux/ar71xx/base-files/lib/ar71xx.sh
+++ b/target/linux/ar71xx/base-files/lib/ar71xx.sh
@@ -754,6 +754,12 @@ ar71xx_board_detect() {
 	*"GL-AR750")
 		name="gl-ar750"
 		;;
+	*"GL-AR750S")
+		name="gl-ar750s"
+		;;
+	*"GL-X750-4G")
+		name="gl-x750-4g"
+		;;
 	*"GL-CONNECT INET v1")
 		name="gl-inet"
 
diff --git a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
index ca1270b..7c845ae 100755
--- a/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ar71xx/base-files/lib/upgrade/platform.sh
@@ -194,6 +194,40 @@ alfa_check_image() {
 	return 0
 }
 
+gl_board_is_nand() {
+        local size="$(mtd_get_part_size 'ubi')"
+        case "$size" in
+        132120576)
+                return 0
+                ;;
+        134217728)
+                return 0
+                ;;
+        *)
+                return 1
+                ;;
+        esac
+}
+
+# $(1) image file
+# $(2) board name
+# $(3) magic
+platform_check_image_gl_nand() {
+        local board=$2
+        local magic=$3
+
+        if gl_board_is_nand; then
+                nand_do_platform_check $board $1
+                return $?
+        else
+                [ "$magic" != "2705" ] && {
+                        echo "Invalid image type."
+                        return 1
+                }
+                return 0
+        fi
+}
+
 platform_check_image() {
 	local board=$(board_name)
 	local magic="$(get_magic_word "$1")"
@@ -264,7 +298,6 @@ platform_check_image() {
 	ew-dorin|\
 	ew-dorin-router|\
 	gl-ar150|\
-	gl-ar300m|\
 	gl-ar300|\
 	gl-ar750|\
 	gl-domino|\
@@ -332,6 +365,12 @@ platform_check_image() {
 
 		return 0
 		;;
+	gl-ar300m|\
+	gl-x750-4g|\
+        gl-ar750s)
+                platform_check_image_gl_nand "$1" "$board" "$magic" && return 0
+                return 1
+                ;;
 	alfa-ap96|\
 	alfa-nx|\
 	ap121|\
@@ -723,6 +762,12 @@ platform_check_image() {
 	return 1
 }
 
+platform_pre_upgrade_gl_nand() {
+        if gl_board_is_nand; then
+                nand_do_upgrade "$1"
+        fi
+}
+
 platform_pre_upgrade() {
 	local board=$(board_name)
 
@@ -744,6 +789,11 @@ platform_pre_upgrade() {
 		# erase firmware if booted from initramfs
 		[ -z "$(rootfs_type)" ] && mtd erase firmware
 		;;
+	gl-ar300m|\
+	gl-x750-4g|\
+	gl-ar750s)
+		platform_pre_upgrade_gl_nand "$1"
+		;;
 	esac
 }
 
diff --git a/target/linux/ar71xx/config-4.9 b/target/linux/ar71xx/config-4.9
index 8aa0b41..49e2d37 100644
--- a/target/linux/ar71xx/config-4.9
+++ b/target/linux/ar71xx/config-4.9
@@ -124,10 +124,12 @@ CONFIG_ATH79=y
 # CONFIG_ATH79_MACH_GL_AR300 is not set
 # CONFIG_ATH79_MACH_GL_AR300M is not set
 # CONFIG_ATH79_MACH_GL_AR750 is not set
+# CONFIG_ATH79_MACH_GL_AR750S is not set
 # CONFIG_ATH79_MACH_GL_DOMINO is not set
 # CONFIG_ATH79_MACH_GL_INET is not set
 # CONFIG_ATH79_MACH_GL_MIFI is not set
 # CONFIG_ATH79_MACH_GL_USB150 is not set
+# CONFIG_ATH79_MACH_GL_X750_4G is not set
 # CONFIG_ATH79_MACH_GS_OOLITE_V1 is not set
 # CONFIG_ATH79_MACH_GS_OOLITE_V5_2 is not set
 # CONFIG_ATH79_MACH_HIVEAP_121 is not set
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt b/target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt
index e7655b3..86ea064 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt
+++ b/target/linux/ar71xx/files/arch/mips/ath79/Kconfig.openwrt
@@ -847,6 +847,28 @@ config ATH79_MACH_GL_AR750
 	select ATH79_DEV_USB
 	select ATH79_DEV_WMAC
 
+config ATH79_MACH_GL_X750_4G
+	bool "GL.iNet GL-X750_4G support"
+	select SOC_QCA953X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
+config ATH79_MACH_GL_AR750S
+	bool "GL.iNet GL-AR750S support"
+	select SOC_QCA956X
+	select ATH79_DEV_AP9X_PCI if PCI
+	select ATH79_DEV_ETH
+	select ATH79_DEV_GPIO_BUTTONS
+	select ATH79_DEV_LEDS_GPIO
+	select ATH79_DEV_M25P80
+	select ATH79_DEV_USB
+	select ATH79_DEV_WMAC
+
 config ATH79_MACH_GL_DOMINO
 	bool "DOMINO support"
 	select SOC_AR933X
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/Makefile b/target/linux/ar71xx/files/arch/mips/ath79/Makefile
index 8800a7d..9307a49 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/Makefile
+++ b/target/linux/ar71xx/files/arch/mips/ath79/Makefile
@@ -135,6 +135,8 @@ obj-$(CONFIG_ATH79_MACH_GL_AR150)		+= mach-gl-ar150.o
 obj-$(CONFIG_ATH79_MACH_GL_AR300)		+= mach-gl-ar300.o
 obj-$(CONFIG_ATH79_MACH_GL_AR300M)		+= mach-gl-ar300m.o
 obj-$(CONFIG_ATH79_MACH_GL_AR750)		+= mach-gl-ar750.o
+obj-$(CONFIG_ATH79_MACH_GL_X750_4G)		+= mach-gl-x750-4g.o
+obj-$(CONFIG_ATH79_MACH_GL_AR750S)		+= mach-gl-ar750s.o
 obj-$(CONFIG_ATH79_MACH_GL_DOMINO)		+= mach-gl-domino.o
 obj-$(CONFIG_ATH79_MACH_GL_INET)		+= mach-gl-inet.o
 obj-$(CONFIG_ATH79_MACH_GL_MIFI)		+= mach-gl-mifi.o
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c
index 2a2d270..2b7b278 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar300m.c
@@ -22,7 +22,6 @@
 #include "dev-eth.h"
 #include "dev-gpio-buttons.h"
 #include "dev-leds-gpio.h"
-#include "dev-m25p80.h"
 #include "dev-usb.h"
 #include "dev-spi.h"
 #include "dev-wmac.h"
@@ -109,7 +108,7 @@ static struct spi_board_info gl_ar300m_spi_info[] = {
 		.bus_num	= 0,
 		.chip_select	= 1,
 		.max_speed_hz	= 25000000,
-		.modalias	= "ath79-spinand",
+		.modalias	= "generic-spinand-controller",
 		.platform_data	= NULL,
 	}
 };
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c
new file mode 100755
index 0000000..e66997a
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-ar750s.c
@@ -0,0 +1,202 @@
+/*
+ *  Ubiquiti UniFi AC (LITE) board support
+ *
+ *  Copyright (C) 2015-2016 P. Wassi <p.wassi at gmx.at>
+ *
+ *  Derived from: mach-ubnt-xm.c
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/ath9k_platform.h>
+#include <linux/etherdevice.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/irq.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include <linux/platform_data/phy-at803x.h>
+#include <linux/ar8216_platform.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-m25p80.h"
+#include "dev-wmac.h"
+#include "dev-usb.h"
+#include "machtypes.h"
+
+
+#define GL_AR750S_KEYS_POLL_INTERVAL	20
+#define GL_AR750S_KEYS_DEBOUNCE_INTERVAL	(3 * GL_AR750S_KEYS_POLL_INTERVAL)
+
+
+#define GL_AR750S_GPIO_LED_WLAN2G       19
+#define GL_AR750S_GPIO_LED_WLAN5G       20
+#define GL_AR750S_GPIO_LED_POWER	1
+#define GL_AR750S_GPIO_USB_POWER	7
+
+#define GL_AR750S_GPIO_BTN_RESET	2
+#define GL_AR750S_GPIO_BTN_RIGHT	8
+
+#define GL_AR750S_MAC0_OFFSET             0x0000
+#define GL_AR750S_WMAC_CALDATA_OFFSET     0x1000
+#define GL_AR750S_PCI_CALDATA_OFFSET      0x5000
+
+#define GL_AR750S_GPIO_I2C_SDA	5
+#define GL_AR750S_GPIO_I2C_SCL	21
+
+
+
+static struct spi_board_info gl_ar750s_spi_info[] = {
+    {
+        .bus_num    = 0,
+        .chip_select    = 0,
+        .max_speed_hz   = 25000000,
+        .modalias   = "m25p80",
+        .platform_data  = NULL,
+    },
+    {
+        .bus_num    = 0,
+        .chip_select    = 1,
+        .max_speed_hz   = 25000000,
+        .modalias   = "generic-spinand-controller",
+        .platform_data  = NULL,
+    }
+};
+
+static struct ath79_spi_platform_data gl_ar750s_spi_data = {
+    .bus_num        = 0,
+    .num_chipselect     = 2,
+};
+
+static struct gpio_led gl_ar750s_leds_gpio[] __initdata = {
+	{
+		 .name           = "gl-ar750s:white:power",
+		 .gpio           = GL_AR750S_GPIO_LED_POWER,
+		.default_state  = LEDS_GPIO_DEFSTATE_KEEP,
+		.active_low     = 1,
+   	 },{
+		 .name           = "gl-ar750s:white:usbpower",
+		 .gpio           = GL_AR750S_GPIO_USB_POWER,
+		.active_low     = 1,
+   	 },{
+		.name		= "gl-ar750s:white:wlan2g",
+		.gpio		= GL_AR750S_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	},{
+		.name		= "gl-ar750s:white:wlan5g",
+		.gpio		= GL_AR750S_GPIO_LED_WLAN5G,
+		.active_low	= 0,
+	}
+};
+
+static struct gpio_keys_button gl_ar750s_gpio_keys[] __initdata = {
+    {
+        .desc                   = "reset",
+        .type                   = EV_KEY,
+        .code                   = KEY_RESTART,
+        .debounce_interval      = GL_AR750S_KEYS_DEBOUNCE_INTERVAL,
+        .gpio                   = GL_AR750S_GPIO_BTN_RESET,
+        .active_low             = 1,
+       }, {
+        .desc                   = "right",
+        .type                   = EV_KEY,
+        .code                   = BTN_0,
+        .debounce_interval      = GL_AR750S_KEYS_DEBOUNCE_INTERVAL,
+        .gpio                   = GL_AR750S_GPIO_BTN_RIGHT,
+        .active_low             = 1,
+       },
+};
+
+static struct i2c_gpio_platform_data gl_ar750s_i2c_gpio_data = {
+        .sda_pin        = GL_AR750S_GPIO_I2C_SDA,
+        .scl_pin        = GL_AR750S_GPIO_I2C_SCL,
+};
+
+static struct platform_device gl_ar750s_i2c_gpio_device = {
+        .name           = "i2c-gpio",
+        .id             = 0,
+        .dev = {
+                .platform_data  = &gl_ar750s_i2c_gpio_data,
+	}
+
+};
+
+static struct ar8327_pad_cfg gl_ar750s_ar8327_pad0_cfg = {
+	.mode = AR8327_PAD_MAC_SGMII,
+	.sgmii_delay_en = true,
+};
+
+static struct ar8327_platform_data gl_ar750s_ar8327_data = {
+	.pad0_cfg = &gl_ar750s_ar8327_pad0_cfg,
+	.port0_cfg = {
+		.force_link = 1,
+		.speed = AR8327_PORT_SPEED_1000,
+		.duplex = 1,
+		.txpause = 1,
+		.rxpause = 1,
+	},
+};
+
+
+static struct mdio_board_info gl_ar750s_mdio0_info[] = {
+	{
+		.bus_id = "ag71xx-mdio.0",
+		.phy_addr = 0,
+		.platform_data = &gl_ar750s_ar8327_data,
+	},
+};
+
+static void __init  gl_ar750s_setup(void)
+{
+	u8 *eeprom = (u8 *) KSEG1ADDR(0x1f050000);
+
+	ath79_register_spi(&gl_ar750s_spi_data, gl_ar750s_spi_info, 2);
+
+	ath79_init_mac(ath79_eth0_data.mac_addr,
+	               eeprom + GL_AR750S_MAC0_OFFSET, 0);
+
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_SGMII;
+	ath79_eth0_data.mii_bus_dev = &ath79_mdio0_device.dev;
+	ath79_eth0_data.phy_mask = BIT(0);
+
+	mdiobus_register_board_info(gl_ar750s_mdio0_info,
+	                            ARRAY_SIZE(gl_ar750s_mdio0_info));
+
+	ath79_register_mdio(0, 0x00);
+	ath79_register_eth(0);
+
+
+	ath79_register_usb();
+
+
+	ath79_register_wmac(eeprom + GL_AR750S_WMAC_CALDATA_OFFSET, NULL);
+
+
+	ap91_pci_init(eeprom + GL_AR750S_PCI_CALDATA_OFFSET, NULL);
+
+	platform_device_register(&gl_ar750s_i2c_gpio_device);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_ar750s_leds_gpio),
+	                         gl_ar750s_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GL_AR750S_KEYS_POLL_INTERVAL,
+	                                ARRAY_SIZE(gl_ar750s_gpio_keys),
+	                                gl_ar750s_gpio_keys);
+}
+
+
+MIPS_MACHINE(ATH79_MACH_GL_AR750S, "GL-AR750S", "GL-AR750S",
+         gl_ar750s_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c
index a5c68ed..a588b3d 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-mifi.c
@@ -31,6 +31,8 @@
 
 #define GL_MIFI_GPIO_BTN_RESET    11
 
+#define GL_MIFI_GPIO_USB_POWER		6
+
 #define GL_MIFI_KEYS_POLL_INTERVAL	20	/* msecs */
 #define GL_MIFI_KEYS_DEBOUNCE_INTERVAL	(3 * GL_MIFI_KEYS_POLL_INTERVAL)
 
@@ -97,6 +99,10 @@ static void __init gl_mifi_setup(void)
 					ARRAY_SIZE(gl_mifi_gpio_keys),
 					gl_mifi_gpio_keys);
 
+	gpio_request_one(GL_MIFI_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "usbpower");
+
 	/* enable usb */
 	ath79_register_usb();
 
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c
index 6cc27e1..e63fc62 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-usb150.c
@@ -37,6 +37,7 @@ static struct gpio_led gl_usb150_leds_gpio[] __initdata = {
 	{
 		.name		= "gl-usb150:green:power",
 		.gpio		= GL_USB150_GPIO_LED_POWER,
+		.default_state	= LEDS_GPIO_DEFSTATE_ON,
 		.active_low	= 0,
 	}, {
 		.name		= "gl-usb150:green:wlan",
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-x750-4g.c b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-x750-4g.c
new file mode 100644
index 0000000..40922e6
--- /dev/null
+++ b/target/linux/ar71xx/files/arch/mips/ath79/mach-gl-x750-4g.c
@@ -0,0 +1,176 @@
+/*
+ * GL.iNet GL-X750-4G board support
+ *
+ * Copyright (C) 2018 Piotr Dymacz <pepe2k@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c-gpio.h>
+#include <linux/platform_device.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+
+#include "common.h"
+#include "dev-ap9x-pci.h"
+#include "dev-eth.h"
+#include "dev-gpio-buttons.h"
+#include "dev-leds-gpio.h"
+#include "dev-spi.h"
+#include "dev-usb.h"
+#include "dev-wmac.h"
+#include "machtypes.h"
+
+#define GL_X750_4G_GPIO_LED_POWER		12
+#define GL_X750_4G_GPIO_LED_WLAN2G	4
+#define GL_X750_4G_GPIO_LED_WLAN5G	13
+#define GL_X750_4G_GPIO_LED_4G	15
+#define GL_X750_4G_GPIO_LED_WAN		14
+
+#define GL_X750_4G_GPIO_BTN_RESET		3
+
+#define GL_X750_4G_GPIO_I2C_SCL		16
+#define GL_X750_4G_GPIO_I2C_SDA		1
+
+#define GL_X750_4G_GPIO_USB_POWER		2
+#define GL_X750_4G_GPIO_PCI_POWER		0
+
+#define GL_X750_4G_KEYS_POLL_INTERVAL	20
+#define GL_X750_4G_KEYS_DEBOUNCE_INTERVAL	(3 * GL_X750_4G_KEYS_POLL_INTERVAL)
+
+#define GL_X750_4G_MAC0_OFFSET		0
+#define GL_X750_4G_WMAC2G_CALDATA_OFFSET	0x1000
+#define GL_X750_4G_WMAC5G_CALDATA_OFFSET	0x5000
+
+static struct gpio_led gl_x750_4g_leds_gpio[] __initdata = {
+	{
+		.name		= "gl-x750-4g:white:power",
+		.gpio		= GL_X750_4G_GPIO_LED_POWER,
+		.default_state	= LEDS_GPIO_DEFSTATE_KEEP,
+		.active_low	= 1,
+	}, {
+		.name		= "gl-x750-4g:white:wlan2g",
+		.gpio		= GL_X750_4G_GPIO_LED_WLAN2G,
+		.active_low	= 1,
+	}, {
+		.name		= "gl-x750-4g:white:wlan5g",
+		.gpio		= GL_X750_4G_GPIO_LED_WLAN5G,
+		.active_low	= 1,
+	},{
+		.name		= "gl-x750-4g:white:wan",
+		.gpio		= GL_X750_4G_GPIO_LED_WAN,
+		.active_low	= 1,
+	}, {
+		.name		= "gl-x750-4g:white:4g",
+		.gpio		= GL_X750_4G_GPIO_LED_4G,
+		.active_low	= 1,
+	},
+};
+
+static struct gpio_keys_button gl_x750_4g_gpio_keys[] __initdata = {
+	{
+		.desc			= "reset",
+		.type			= EV_KEY,
+		.code			= KEY_RESTART,
+		.debounce_interval	= GL_X750_4G_KEYS_DEBOUNCE_INTERVAL,
+		.gpio			= GL_X750_4G_GPIO_BTN_RESET,
+		.active_low		= 1,
+	},
+};
+
+/*static struct i2c_gpio_platform_data gl_x750_4g_i2c_gpio_data = {
+	.sda_pin = GL_X750_4G_GPIO_I2C_SDA,
+	.scl_pin = GL_X750_4G_GPIO_I2C_SCL,
+};
+
+static struct platform_device gl_x750_4g_i2c_gpio = {
+	.name	= "i2c-gpio",
+	.id	= 0,
+	.dev	= {
+		.platform_data = &gl_x750_4g_i2c_gpio_data,
+	},
+};*/
+
+static struct spi_board_info gl_x750_4g_spi_info[] = {
+    {
+        .bus_num    = 0,
+        .chip_select    = 0,
+        .max_speed_hz   = 25000000,
+        .modalias   = "m25p80",
+        .platform_data  = NULL,
+    },
+    {
+        .bus_num    = 0,
+        .chip_select    = 1,
+        .max_speed_hz   = 25000000,
+        .modalias   = "generic-spinand-controller",
+        .platform_data  = NULL,
+    }
+};
+
+static struct ath79_spi_platform_data gl_x750_4g_spi_data = {
+    .bus_num        = 0,
+    .num_chipselect     = 2,
+};
+
+static void __init gl_x750_4g_setup(void)
+{
+	u8 *art = (u8 *) KSEG1ADDR(0x1f050000);
+
+	ath79_register_spi(&gl_x750_4g_spi_data, gl_x750_4g_spi_info, 2);
+
+	ath79_register_mdio(0, 0x0);
+	//ath79_register_mdio(1, 0x0);
+
+	ath79_switch_data.phy4_mii_en = 1;
+	ath79_switch_data.phy_poll_mask |= BIT(4);
+
+	/* WAN */
+	ath79_eth0_data.duplex = DUPLEX_FULL;
+	ath79_eth0_data.phy_if_mode = PHY_INTERFACE_MODE_MII;
+	ath79_eth0_data.phy_mask = BIT(4);
+	ath79_eth0_data.speed = SPEED_100;
+	ath79_init_mac(ath79_eth0_data.mac_addr, art + GL_X750_4G_MAC0_OFFSET, 0);
+	ath79_register_eth(0);
+
+	/* LAN */
+	ath79_eth1_data.duplex = DUPLEX_FULL;
+	ath79_eth1_data.phy_if_mode = PHY_INTERFACE_MODE_GMII;
+	ath79_eth1_data.speed = SPEED_1000;
+	ath79_init_mac(ath79_eth1_data.mac_addr, art + GL_X750_4G_MAC0_OFFSET, 1);
+	ath79_register_eth(1);
+
+	/* Disable JTAG (enables GPIO0-3) */
+	ath79_gpio_function_enable(AR934X_GPIO_FUNC_JTAG_DISABLE);
+
+	ath79_register_leds_gpio(-1, ARRAY_SIZE(gl_x750_4g_leds_gpio),
+				 gl_x750_4g_leds_gpio);
+
+	ath79_register_gpio_keys_polled(-1, GL_X750_4G_KEYS_POLL_INTERVAL,
+					ARRAY_SIZE(gl_x750_4g_gpio_keys),
+					gl_x750_4g_gpio_keys);
+
+	gpio_request_one(GL_X750_4G_GPIO_USB_POWER,
+			 GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+			 "USB power");
+
+        gpio_request_one(GL_X750_4G_GPIO_PCI_POWER,
+                         GPIOF_OUT_INIT_LOW | GPIOF_EXPORT_DIR_FIXED,
+                         "PCI power");
+
+//	platform_device_register(&gl_x750_4g_i2c_gpio);
+
+	ath79_register_usb();
+
+	ath79_register_wmac(art + GL_X750_4G_WMAC2G_CALDATA_OFFSET, NULL);
+
+	ap91_pci_init(art + GL_X750_4G_WMAC5G_CALDATA_OFFSET, NULL);
+}
+
+MIPS_MACHINE(ATH79_MACH_GL_X750_4G, "GL-X750-4G", "GL.iNet GL-X750-4G",
+	     gl_x750_4g_setup);
diff --git a/target/linux/ar71xx/files/arch/mips/ath79/machtypes.h b/target/linux/ar71xx/files/arch/mips/ath79/machtypes.h
index 390ec0b..a7fef0b 100644
--- a/target/linux/ar71xx/files/arch/mips/ath79/machtypes.h
+++ b/target/linux/ar71xx/files/arch/mips/ath79/machtypes.h
@@ -131,6 +131,8 @@ enum ath79_mach_type {
 	ATH79_MACH_GL_AR300,			/* GL-AR300 */
 	ATH79_MACH_GL_AR300M,			/* GL-AR300M */
 	ATH79_MACH_GL_AR750,			/* GL.iNet GL-AR750 */
+	ATH79_MACH_GL_X750_4G,			/* GL.iNet GL-X750-4G */
+	ATH79_MACH_GL_AR750S,			/* GL.iNet GL-AR750S */
 	ATH79_MACH_GL_DOMINO,			/* Domino */
 	ATH79_MACH_GL_INET,			/* GL-CONNECT GL-INET */
 	ATH79_MACH_GL_MIFI,			/* GL-MIFI support */
diff --git a/target/linux/ar71xx/generic/config-default b/target/linux/ar71xx/generic/config-default
index da331d3..d71e8fc 100644
--- a/target/linux/ar71xx/generic/config-default
+++ b/target/linux/ar71xx/generic/config-default
@@ -97,6 +97,8 @@ CONFIG_ATH79_MACH_GL_AR150=y
 CONFIG_ATH79_MACH_GL_AR300=y
 CONFIG_ATH79_MACH_GL_AR300M=y
 CONFIG_ATH79_MACH_GL_AR750=y
+CONFIG_ATH79_MACH_GL_X750_4G=y
+CONFIG_ATH79_MACH_GL_AR750S=y
 CONFIG_ATH79_MACH_GL_DOMINO=y
 CONFIG_ATH79_MACH_GL_INET=y
 CONFIG_ATH79_MACH_GL_MIFI=y
diff --git a/target/linux/ar71xx/image/generic.mk b/target/linux/ar71xx/image/generic.mk
index 6405575..2928e17 100644
--- a/target/linux/ar71xx/image/generic.mk
+++ b/target/linux/ar71xx/image/generic.mk
@@ -518,6 +518,32 @@ define Device/gl-ar750
 endef
 TARGET_DEVICES += gl-ar750
 
+define Device/gl-x750-4g
+  DEVICE_TITLE := GL.iNet GL-X750-4G
+  DEVICE_PACKAGES := kmod-ath10k ath10k-firmware-qca9887 kmod-usb-core \
+	kmod-usb2 kmod-usb-storage
+  BOARDNAME := GL-X750-4G
+  SUPPORTED_DEVICES := gl-x750-4g
+  IMAGE_SIZE := 16000k
+  MTDPARTS := spi0.0:256k(u-boot)ro,64k(u-boot-env),64k(art)ro,-(firmware)
+  IMAGE/sysupgrade.bin := append-kernel | pad-to $$$$(BLOCKSIZE) | \
+	append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+endef
+TARGET_DEVICES += gl-x750-4g
+
+define Device/gl-ar750s
+  DEVICE_TITLE := GL.iNet GL-AR750S
+  DEVICE_PACKAGES := kmod-ath10k ath10k-firmware-qca9887 kmod-usb-core \
+	kmod-usb2 kmod-usb-storage
+  BOARDNAME := GL-AR750S
+  SUPPORTED_DEVICES := gl-ar750s
+  IMAGE_SIZE := 16000k
+  MTDPARTS := spi0.0:256k(u-boot)ro,64k(u-boot-env),64k(art)ro,-(firmware)
+  IMAGE/sysupgrade.bin := append-kernel | pad-to $$$$(BLOCKSIZE) | \
+	append-rootfs | pad-rootfs | append-metadata | check-size $$$$(IMAGE_SIZE)
+endef
+TARGET_DEVICES += gl-ar750s
+
 define Device/gl-domino
   DEVICE_TITLE := GL.iNet Domino Pi
   DEVICE_PACKAGES := kmod-usb-core kmod-usb2
diff --git a/target/linux/ar71xx/image/legacy.mk b/target/linux/ar71xx/image/legacy.mk
index cbc859d..cffa08f 100644
--- a/target/linux/ar71xx/image/legacy.mk
+++ b/target/linux/ar71xx/image/legacy.mk
@@ -274,6 +274,9 @@ wndr4300_mtdlayout=mtdparts=ar934x-nfc:256k(u-boot)ro,256k(u-boot-env)ro,256k(ca
 zcn1523h_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env)ro,6208k(rootfs),1472k(kernel),64k(configure)ro,64k(mfg)ro,64k(art)ro,7680k@0x50000(firmware)
 mynet_rext_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,7808k(firmware),64k(nvram)ro,64k(ART)ro
 zyx_nbg6716_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(env)ro,64k(RFdata)ro,-(nbu);ar934x-nfc:2048k(zyxel_rfsd),2048k(romd),1024k(header),2048k(kernel),-(ubi)
+gl-ar750s_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env),64k(art)ro,2048k(kernel),13052k(reserved);spi0.1:-(ubi)
+gl-x750-4g_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env),64k(art)ro,2048k(kernel),13052k(reserved);spi0.1:-(ubi)
+gl-ar300m_mtdlayout=mtdparts=spi0.0:256k(u-boot)ro,64k(u-boot-env),16000k(reserved),64k(art)ro;spi0.1:2048k(kernel),-(ubi)
 
 define Image/BuildKernel
 	cp $(KDIR)/vmlinux.elf $(VMLINUX).elf
@@ -803,6 +806,33 @@ define Image/Build/ZyXELNAND
 	$(call Image/Build/SysupgradeNAND,$(2),squashfs,$(KDIR_TMP)/$(2)-kernel.jffs2)
 endef
 
+Image/Build/GLNAND/initramfs=$(call MkuImageLzma/initramfs,$(2),$(3) $(4))
+Image/Build/GLNAND/buildkernel=$(call MkuImageLzma,$(2),$(3) $(4))
+
+ #$(1): rootfs image suffix
+ #$(2): Board name (small caps)
+ #$(3): Kernel board specific cmdline
+ #$(4): Kernel mtdparts definition
+ #$(5): suffix of the configuration file for ubinize
+define Image/Build/GLNAND
+        $(eval kernelsize=$(call mtdpartsize,kernel,$(4)))
+        $(CP) $(KDIR)/root.squashfs-raw $(KDIR_TMP)/root.squashfs
+        echo -ne '\xde\xad\xc0\xde' > $(KDIR_TMP)/jffs2.eof
+        $(call ubinize,ubinize-$(5).ini,$(KDIR_TMP),$(KDIR_TMP)/$(2)-root.ubi,128KiB,2048,)
+
+        ( \
+                dd if=$(KDIR_TMP)/vmlinux-$(2).uImage \
+                        of=$(call imgname,kernel,$(2)).bin conv=sync; \
+                dd if=$(KDIR_TMP)/$(2)-root.ubi \
+                        of=$(call imgname,$(1),$(2)-rootfs).ubi bs=128k conv=sync; \
+        )
+        ( \
+                dd if=$(call imgname,kernel,$(2)).bin bs=$(kernelsize) conv=sync; \
+                dd if=$(call imgname,$(1),$(2)-rootfs).ubi \
+        ) > $(call imgname,ubi-factory,$(2)).img
+
+        $(call Image/Build/SysupgradeNAND,$(2),squashfs,$(KDIR_TMP)/vmlinux-$(2).uImage)
+endef
 
 Image/Build/OpenMesh/buildkernel=$(call MkuImageLzma,$(2))
 Image/Build/OpenMesh/initramfs=$(call MkuImageLzma/initramfs,$(2),)
@@ -1021,6 +1051,9 @@ $(eval $(call SingleProfile,NetgearNAND,64k,WNDR4300V1,wndr4300,WNDR4300,ttyS0,1
 $(eval $(call SingleProfile,NetgearNAND,64k,R6100,r6100,R6100,ttyS0,115200,$$(r6100_mtdlayout),0x36303030,R6100,"",-H 29764434+0+128+128+2x2+2x2,wndr4300))
 
 $(eval $(call SingleProfile,ZyXELNAND,128k,NBG6716,nbg6716,NBG6716,ttyS0,115200,NBG6716,$$(zyx_nbg6716_mtdlayout),mem=256M))
+$(eval $(call SingleProfile,GLNAND,64k,GL-AR750S,gl-ar750s,GL-AR750S,ttyS0,115200,$$(gl-ar750s_mtdlayout),gl-ar750s))
+$(eval $(call SingleProfile,GLNAND,64k,GL-X750-4G,gl-x750-4g,GL-X750-4G,ttyS0,115200,$$(gl-x750-4g_mtdlayout),gl-x750-4g))
+$(eval $(call SingleProfile,GLNAND,64k,GL-AR300M,gl-ar300m,GL-AR300M,ttyS0,115200,$$(gl-ar300m_mtdlayout),gl-ar300m))
 
 endif # ifeq ($(SUBTARGET),nand)
 
diff --git a/target/linux/ar71xx/image/nand.mk b/target/linux/ar71xx/image/nand.mk
index ba9e1ba..53d7b92 100644
--- a/target/linux/ar71xx/image/nand.mk
+++ b/target/linux/ar71xx/image/nand.mk
@@ -130,8 +130,29 @@ define LegacyDevice/WNDR4300V1
 endef
 LEGACY_DEVICES += WNDR4300V1
 
+
 define LegacyDevice/NBG6716
   DEVICE_TITLE := Zyxel NBG 6716
   DEVICE_PACKAGES := kmod-rtc-pcf8563 kmod-ath10k ath10k-firmware-qca988x
 endef
 LEGACY_DEVICES += NBG6716
+
+define LegacyDevice/GL-AR750S
+	DEVICE_TITLE := GL-AR750S with nand flash
+	DEVICE_PACKAGES :=  kmod-ath10k ath10k-firmware-qca9887 kmod-usb-core \
+	      kmod-usb2 kmod-usb-storage
+endef
+LEGACY_DEVICES += GL-AR750S
+
+define LegacyDevice/GL-X750-4G
+	DEVICE_TITLE := GL-X750-4G with nand flash
+	DEVICE_PACKAGES :=  kmod-ath10k ath10k-firmware-qca9887 kmod-usb-core \
+	      kmod-usb2 kmod-usb-storage
+endef
+LEGACY_DEVICES += GL-X750-4G
+
+define LegacyDevice/GL-AR300M
+	DEVICE_TITLE := GL-AR300M with nand flash
+	DEVICE_PACKAGES :=  kmod-usb-core kmod-usb2 kmod-usb-storage
+endef
+LEGACY_DEVICES += GL-AR300M
diff --git a/target/linux/ar71xx/image/ubinize-gl-ar300m.ini b/target/linux/ar71xx/image/ubinize-gl-ar300m.ini
new file mode 100644
index 0000000..5bff906
--- /dev/null
+++ b/target/linux/ar71xx/image/ubinize-gl-ar300m.ini
@@ -0,0 +1,26 @@
+[rootfs]
+# Volume mode (other option is static)
+mode=ubi
+# Source image
+image=root.squashfs
+# Volume ID in UBI image
+vol_id=0
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs
+# Autoresize volume at first mount
+# vol_flags=autoresize
+
+[rootfs_data]
+# Volume mode (other option is static)
+mode=ubi
+# Volume ID in UBI image
+vol_id=1
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs_data
+# Autoresize volume at first mount
+vol_flags=autoresize
+vol_size=1MiB
diff --git a/target/linux/ar71xx/image/ubinize-gl-ar750s.ini b/target/linux/ar71xx/image/ubinize-gl-ar750s.ini
new file mode 100644
index 0000000..5bff906
--- /dev/null
+++ b/target/linux/ar71xx/image/ubinize-gl-ar750s.ini
@@ -0,0 +1,26 @@
+[rootfs]
+# Volume mode (other option is static)
+mode=ubi
+# Source image
+image=root.squashfs
+# Volume ID in UBI image
+vol_id=0
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs
+# Autoresize volume at first mount
+# vol_flags=autoresize
+
+[rootfs_data]
+# Volume mode (other option is static)
+mode=ubi
+# Volume ID in UBI image
+vol_id=1
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs_data
+# Autoresize volume at first mount
+vol_flags=autoresize
+vol_size=1MiB
diff --git a/target/linux/ar71xx/image/ubinize-gl-x750-4g.ini b/target/linux/ar71xx/image/ubinize-gl-x750-4g.ini
new file mode 100644
index 0000000..5bff906
--- /dev/null
+++ b/target/linux/ar71xx/image/ubinize-gl-x750-4g.ini
@@ -0,0 +1,26 @@
+[rootfs]
+# Volume mode (other option is static)
+mode=ubi
+# Source image
+image=root.squashfs
+# Volume ID in UBI image
+vol_id=0
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs
+# Autoresize volume at first mount
+# vol_flags=autoresize
+
+[rootfs_data]
+# Volume mode (other option is static)
+mode=ubi
+# Volume ID in UBI image
+vol_id=1
+# Allow for dynamic resize
+vol_type=dynamic
+# Volume name
+vol_name=rootfs_data
+# Autoresize volume at first mount
+vol_flags=autoresize
+vol_size=1MiB
diff --git a/target/linux/ar71xx/nand/config-default b/target/linux/ar71xx/nand/config-default
index 39b1ca4..df4b0ed 100644
--- a/target/linux/ar71xx/nand/config-default
+++ b/target/linux/ar71xx/nand/config-default
@@ -16,6 +16,9 @@ CONFIG_ATH79_MACH_R6100=y
 CONFIG_ATH79_MACH_RAMBUTAN=y
 CONFIG_ATH79_MACH_WI2A_AC200I=y
 CONFIG_ATH79_MACH_WNDR4300=y
+CONFIG_ATH79_MACH_GL_AR750S=y
+CONFIG_ATH79_MACH_GL_AR300M=y
+CONFIG_ATH79_MACH_GL_X750_4G=y
 CONFIG_ATH79_MACH_Z1=y
 CONFIG_ATH79_NVRAM=y
 CONFIG_ATH79_PCI_ATH9K_FIXUP=y
@@ -43,6 +46,7 @@ CONFIG_MTD_NAND_AR934X_HW_ECC=y
 CONFIG_MTD_NAND_BCH=y
 CONFIG_MTD_NAND_ECC=y
 CONFIG_MTD_NAND_ECC_BCH=y
+CONFIG_MTD_NAND_SPI_NAND=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 # CONFIG_MTD_SPLIT_EVA_FW is not set
 # CONFIG_MTD_SPLIT_SEAMA_FW is not set
diff --git a/target/linux/ar71xx/patches-4.9/491-mtd-spi-nand-driver.patch b/target/linux/ar71xx/patches-4.9/491-mtd-spi-nand-driver.patch
new file mode 100644
index 0000000..e77ecca
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.9/491-mtd-spi-nand-driver.patch
@@ -0,0 +1,2785 @@
+--- a/drivers/mtd/nand/Kconfig
++++ b/drivers/mtd/nand/Kconfig
+@@ -589,4 +589,12 @@ config MTD_NAND_AR934X_HW_ECC
+ 	bool "Hardware ECC support for the AR934X NAND Controller (EXPERIMENTAL)"
+ 	depends on MTD_NAND_AR934X
+ 
++config MTD_NAND_SPI_NAND
++	tristate "SPI Nand flash support"
++	default n
++	depends on MTD_NAND
++	help
++	  Enables the driver for SPI NAND flash controller on Qualcomm-Atheros System on Chips
++	  This controller is used on families AR71xx and AR9xxx.
++
+ endif # MTD_NAND
+--- a/drivers/mtd/nand/Makefile
++++ b/drivers/mtd/nand/Makefile
+@@ -62,5 +62,6 @@ obj-$(CONFIG_MTD_NAND_HISI504)	        +
+ obj-$(CONFIG_MTD_NAND_BRCMNAND)		+= brcmnand/
+ obj-$(CONFIG_MTD_NAND_QCOM)		+= qcom_nandc.o
+ obj-$(CONFIG_MTD_NAND_MTK)		+= mtk_nand.o mtk_ecc.o
++obj-$(CONFIG_MTD_NAND_SPI_NAND)		+= spi_nand/
+ 
+ nand-objs := nand_base.o nand_bbt.o nand_timings.o
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/Makefile
+@@ -0,0 +1 @@
++obj-$(CONFIG_MTD_NAND_SPI_NAND) += generic-spinand-controller.o core.o bbt.o nand_core.o micron.o etron.o gigadevice.o paragon.o
+\ No newline at end of file
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/bbt.c
+@@ -0,0 +1,79 @@
++/*
++ * Copyright (c) 2017 Free Electrons
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * Authors:
++ *	Boris Brezillon <boris.brezillon@free-electrons.com>
++ *	Peter Pan <peterpandong@micron.com>
++ */
++
++#define pr_fmt(fmt)	"nand-bbt: " fmt
++
++#include <linux/mtd/nand.h>
++#include <linux/slab.h>
++#include <linux/mtd/spinand.h>
++
++int nanddev_bbt_init(struct nand_device *nand)
++{
++	unsigned int nwords = nanddev_neraseblocks(nand);
++
++	nand->bbt.cache = kzalloc(nwords, GFP_KERNEL);
++	if (!nand->bbt.cache)
++		return -ENOMEM;
++	memset(nand->bbt.cache,0,nwords);
++	return 0;
++}
++EXPORT_SYMBOL_GPL(nanddev_bbt_init);
++
++void nanddev_bbt_cleanup(struct nand_device *nand)
++{
++	kfree(nand->bbt.cache);
++}
++EXPORT_SYMBOL_GPL(nanddev_bbt_cleanup);
++
++int nanddev_bbt_update(struct nand_device *nand)
++{
++	return 0;
++}
++EXPORT_SYMBOL_GPL(nanddev_bbt_update);
++
++int nanddev_bbt_get_block_status(const struct nand_device *nand,
++				 unsigned int entry)
++{
++	unsigned char *pos = nand->bbt.cache + entry;
++	unsigned long status;
++
++	if (entry >= nanddev_neraseblocks(nand)){
++		return -ERANGE;
++		}
++
++	status = pos[0];
++
++
++	return status & 0xff;
++}
++EXPORT_SYMBOL_GPL(nanddev_bbt_get_block_status);
++
++int nanddev_bbt_set_block_status(struct nand_device *nand, unsigned int entry,
++				 enum nand_bbt_block_status status)
++{
++	unsigned char *pos = nand->bbt.cache + entry;;
++
++	if (entry >= nanddev_neraseblocks(nand)){
++		return -ERANGE;
++		}
++
++	pos[0] = status & 0xff;
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(nanddev_bbt_set_block_status);
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/core.c
+@@ -0,0 +1,902 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#define pr_fmt(fmt)	"spi-nand: " fmt
++
++#include <linux/kernel.h>
++#include <linux/device.h>
++#include <linux/module.h>
++#include <linux/jiffies.h>
++#include <linux/mtd/spinand.h>
++#include <linux/slab.h>
++#include <linux/of.h>
++static inline void spinand_adjust_cache_op(struct spinand_device *spinand,
++					   const struct nand_page_io_req *req,
++					   struct spinand_op *op)
++{
++	if (!spinand->manufacturer.manu->ops->adjust_cache_op)
++		return;
++
++	spinand->manufacturer.manu->ops->adjust_cache_op(spinand, req, op);
++}
++
++static inline int spinand_exec_op(struct spinand_device *spinand,
++				  struct spinand_op *op)
++{
++	return spinand->controller.controller->ops->exec_op(spinand, op);
++}
++
++static inline void spinand_op_init(struct spinand_op *op)
++{
++	memset(op, 0, sizeof(struct spinand_op));
++	op->addr_nbits = 1;
++	op->data_nbits = 1;
++}
++
++static int spinand_read_reg_op(struct spinand_device *spinand, u8 reg, u8 *val)
++{
++	struct spinand_op op;
++	int ret;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_GET_FEATURE;
++	op.n_addr = 1;
++	op.addr[0] = reg;
++	op.n_rx = 1;
++	op.rx_buf = val;
++
++	ret = spinand_exec_op(spinand, &op);
++	if (ret < 0)
++		pr_err("failed to read register %d (err = %d)\n", reg, ret);
++
++	return ret;
++}
++
++static int spinand_write_reg_op(struct spinand_device *spinand, u8 reg, u8 val)
++{
++	struct spinand_op op;
++	int ret;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_SET_FEATURE;
++	op.n_addr = 1;
++	op.addr[0] = reg;
++	op.n_tx = 1;
++	op.tx_buf = &val;
++
++	ret = spinand_exec_op(spinand, &op);
++	if (ret < 0)
++		pr_err("failed to write register %d (err = %d)\n", reg, ret);
++
++	return ret;
++}
++
++static int spinand_get_cfg(struct spinand_device *spinand, u8 *cfg)
++{
++	return spinand_read_reg_op(spinand, REG_CFG, cfg);
++}
++
++static int spinand_set_cfg(struct spinand_device *spinand, u8 cfg)
++{
++	return spinand_write_reg_op(spinand, REG_CFG, cfg);
++}
++
++static int spinand_read_status(struct spinand_device *spinand, u8 *status)
++{
++	return spinand_read_reg_op(spinand, REG_STATUS, status);
++}
++
++static void spinand_disable_ecc(struct spinand_device *spinand)
++{
++	u8 cfg = 0;
++
++	spinand_get_cfg(spinand, &cfg);
++
++	if ((cfg & CFG_ECC_MASK) == CFG_ECC_ENABLE) {
++		cfg &= ~CFG_ECC_ENABLE;
++		spinand_set_cfg(spinand, cfg);
++	}
++}
++
++static void spinand_enable_ecc(struct spinand_device *spinand)
++{
++	u8 cfg = 0;
++
++	spinand_get_cfg(spinand, &cfg);
++
++	if ((cfg & CFG_ECC_MASK) != CFG_ECC_ENABLE) {
++		cfg |= CFG_ECC_ENABLE;
++		spinand_set_cfg(spinand, cfg);
++	}
++}
++static int spinand_write_enable_op(struct spinand_device *spinand)
++{
++	struct spinand_op op;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_WR_ENABLE;
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_load_page_op(struct spinand_device *spinand,
++				const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = &spinand->base;
++	unsigned int row = nanddev_pos_to_offs(nand, &req->pos);
++	struct spinand_op op;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_PAGE_READ;
++	op.n_addr = 3;
++	unsigned int page = row /nand->memorg.pagesize;
++	unsigned int block = page /nand->memorg.pages_per_eraseblock;
++	op.addr[0] = block >> 10;
++	op.addr[1] = block >> 2;
++	op.addr[2] = ((block & 0x3)<<6)|(page & 0x3f);
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_get_address_bits(u8 opcode)
++{
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++		return 4;
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++		return 2;
++	default:
++		return 1;
++	}
++}
++
++static int spinand_get_data_bits(u8 opcode)
++{
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X4:
++	case SPINAND_CMD_PROG_LOAD_X4:
++	case SPINAND_CMD_PROG_LOAD_RDM_DATA_X4:
++		return 4;
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X2:
++		return 2;
++	default:
++		return 1;
++	}
++}
++
++static int spinand_read_from_cache_op(struct spinand_device *spinand,
++				      const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = &spinand->base;
++	struct nand_page_io_req adjreq = *req;
++	struct spinand_op op;
++	u16 column = 0;
++	int ret;
++
++	spinand_op_init(&op);
++	op.cmd = spinand->read_cache_op;
++	op.n_addr = 3;
++	op.addr_nbits = spinand_get_address_bits(spinand->read_cache_op);
++	if (req->datalen) {
++		adjreq.datalen = nanddev_page_size(nand);
++		adjreq.dataoffs = 0;
++		adjreq.databuf.in = spinand->buf;
++		op.rx_buf = spinand->buf;
++		op.n_rx = adjreq.datalen;
++	}
++
++	if (req->ooblen) {
++		adjreq.ooblen = nanddev_per_page_oobsize(nand);
++		adjreq.ooboffs = 0;
++		adjreq.oobbuf.in = spinand->oobbuf;
++		op.n_rx = nanddev_per_page_oobsize(nand);
++		if (!op.rx_buf) {
++			op.rx_buf = spinand->oobbuf;
++			column = nanddev_page_size(nand);
++		}
++	}
++	op.addr[0] = 0;
++	op.addr[1] = column >> 8;
++	op.addr[2] = column;
++	op.data_nbits = spinand_get_data_bits(spinand->read_cache_op);
++	spinand_adjust_cache_op(spinand, &adjreq, &op);
++
++	ret = spinand_exec_op(spinand, &op);
++	if (ret)
++		return ret;
++
++	if (req->datalen)
++		memcpy(req->databuf.in, spinand->buf + req->dataoffs,
++		       req->datalen);
++
++	if (req->ooblen)
++		memcpy(req->oobbuf.in, spinand->oobbuf + req->ooboffs,
++		       req->ooblen);
++
++	return 0;
++}
++
++static int spinand_write_to_cache_op(struct spinand_device *spinand,
++				     const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = &spinand->base;
++	struct nand_page_io_req adjreq = *req;
++	struct spinand_op op;
++	u16 column = 0;
++
++	spinand_op_init(&op);
++	op.cmd = spinand->write_cache_op;
++	op.n_addr = 2;
++
++	memset(spinand->buf, 0xff,
++	       nanddev_page_size(nand) +
++	       nanddev_per_page_oobsize(nand));
++
++	if (req->datalen) {
++		memcpy(spinand->buf + req->dataoffs, req->databuf.out,
++		       req->datalen);
++		adjreq.dataoffs = 0;
++		adjreq.datalen = nanddev_page_size(nand);
++		adjreq.databuf.out = spinand->buf;
++		op.tx_buf = spinand->buf;
++		op.n_tx = adjreq.datalen;
++	}
++
++	if (req->ooblen) {
++		memcpy(spinand->oobbuf + req->ooboffs, req->oobbuf.out,
++		      req->ooblen);
++		 memset(spinand->oobbuf,0x00,2);
++		adjreq.ooblen = nanddev_per_page_oobsize(nand);
++		adjreq.ooboffs = 0;
++		op.n_tx = nanddev_page_size(nand)+adjreq.ooblen;
++
++		if (!op.tx_buf) {
++			printk("oob write \n");
++			op.tx_buf = spinand->buf;
++			//column = nanddev_page_size(nand);
++		}
++	}
++
++	op.addr[0] = column >> 8;
++	op.addr[1] = column;
++
++	op.addr_nbits = spinand_get_address_bits(spinand->write_cache_op);
++	op.data_nbits = spinand_get_data_bits(spinand->write_cache_op);
++	spinand_adjust_cache_op(spinand, &adjreq, &op);
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_program_op(struct spinand_device *spinand,
++			      const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	unsigned int row = nanddev_pos_to_offs(nand, &req->pos);
++	struct spinand_op op;
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_PROG_EXC;
++	op.n_addr = 3;
++	unsigned int page = row /nand->memorg.pagesize;
++	unsigned int block = page /nand->memorg.pages_per_eraseblock;
++	op.addr[0] = block >> 10;
++	op.addr[1] = block >> 2;
++	op.addr[2] = ((block & 0x3)<<6)|(page & 0x3f);
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_erase_op(struct spinand_device *spinand,
++			    const struct nand_pos *pos)
++{
++	struct nand_device *nand = &spinand->base;
++	unsigned int row = nanddev_pos_to_offs(nand, pos);
++	struct spinand_op op;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_BLK_ERASE;
++	op.n_addr = 3;
++	unsigned int page = row /nand->memorg.pagesize;
++	unsigned int block = page /nand->memorg.pages_per_eraseblock;
++	op.addr[0] = block >> 10;
++	op.addr[1] = block >> 2;
++	op.addr[2] = ((block & 0x3)<<6)|(page & 0x3f);
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_wait(struct spinand_device *spinand, u8 *s)
++{
++	unsigned long timeo =  jiffies + msecs_to_jiffies(400);
++	u8 status;
++
++	do {
++		spinand_read_status(spinand, &status);
++		if ((status & STATUS_OIP_MASK) == STATUS_READY)
++			goto out;
++	} while (time_before(jiffies, timeo));
++
++	/*
++	 * Extra read, just in case the STATUS_READY bit has changed
++	 * since our last check
++	 */
++	spinand_read_status(spinand, &status);
++out:
++	if (s)
++		*s = status;
++
++	return (status & STATUS_OIP_MASK) == STATUS_READY ? 0 :	-ETIMEDOUT;
++}
++
++static int spinand_read_id_op(struct spinand_device *spinand, u8 *buf)
++{
++	struct spinand_op op;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_READ_ID;
++	op.n_rx = SPINAND_MAX_ID_LEN;
++	op.rx_buf = buf;
++
++	return spinand_exec_op(spinand, &op);
++}
++
++static int spinand_reset_op(struct spinand_device *spinand)
++{
++	struct spinand_op op;
++	int ret;
++
++	spinand_op_init(&op);
++	op.cmd = SPINAND_CMD_RESET;
++
++	ret = spinand_exec_op(spinand, &op);
++	if (ret < 0) {
++		pr_err("failed to reset the NAND (err = %d)\n", ret);
++		goto out;
++	}
++
++	ret = spinand_wait(spinand, NULL);
++
++out:
++	return ret;
++}
++
++static int spinand_lock_block(struct spinand_device *spinand, u8 lock)
++{
++	return spinand_write_reg_op(spinand, REG_BLOCK_LOCK, lock);
++}
++
++static int spinand_read_page(struct spinand_device *spinand,
++			     const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	int ret;
++
++	spinand_load_page_op(spinand, req);
++
++	ret = spinand_wait(spinand, NULL);
++	if (ret < 0) {
++		pr_err("failed to load page @%llx (err = %d)\n",
++		       nanddev_pos_to_offs(nand, &req->pos), ret);
++		return ret;
++	}
++
++	spinand_read_from_cache_op(spinand, req);
++
++	return 0;
++}
++
++static int spinand_write_page(struct spinand_device *spinand,
++			      const struct nand_page_io_req *req)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	u8 status;
++	int ret = 0;
++
++	spinand_write_enable_op(spinand);
++	spinand_write_to_cache_op(spinand, req);
++	spinand_program_op(spinand, req);
++
++	ret = spinand_wait(spinand, &status);
++	if (!ret && (status & STATUS_P_FAIL_MASK) == STATUS_P_FAIL)
++		ret = -EIO;
++
++	if (ret < 0)
++		pr_err("failed to program page @%llx (err = %d)\n",
++		       nanddev_pos_to_offs(nand, &req->pos), ret);
++
++	return ret;
++}
++
++static int spinand_mtd_read(struct mtd_info *mtd, loff_t from,
++			    struct mtd_oob_ops *ops)
++{
++	struct spinand_device *spinand = mtd_to_spinand(mtd);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct nand_io_iter iter;
++	int ret;
++
++	mutex_lock(&spinand->lock);
++	nanddev_io_for_each_page(nand, from, ops, &iter) {
++		ret = spinand_read_page(spinand, &iter.req);
++		if (ret)
++			break;
++
++		ops->retlen += iter.req.datalen;
++		ops->oobretlen += iter.req.datalen;
++	}
++	mutex_unlock(&spinand->lock);
++
++	return ret;
++}
++
++static int spinand_mtd_write(struct mtd_info *mtd, loff_t to,
++			     struct mtd_oob_ops *ops)
++{
++	struct spinand_device *spinand = mtd_to_spinand(mtd);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct nand_io_iter iter;
++	int ret = 0;
++	mutex_lock(&spinand->lock);
++	nanddev_io_for_each_page(nand, to, ops, &iter) {
++		ret = spinand_write_page(spinand, &iter.req);
++		if (ret)
++			return ret;
++
++		ops->retlen += iter.req.datalen;
++		ops->oobretlen += iter.req.ooblen;
++	}
++	mutex_unlock(&spinand->lock);
++
++	return ret;
++}
++
++static bool spinand_isbad(struct nand_device *nand, const struct nand_pos *pos)
++{
++	struct spinand_device *spinand = nand_to_spinand(nand);
++	struct nand_page_io_req req = {
++		.pos = *pos,
++		.ooblen = 2,
++		.ooboffs = 0,
++		.oobbuf.in = spinand->oobbuf,
++	};
++
++	memset(spinand->oobbuf, 0, 2);
++	spinand_read_page(spinand, &req);
++	if (spinand->oobbuf[0] != 0xff || spinand->oobbuf[1] != 0xff)
++		return true;
++
++	return false;
++}
++
++static int spinand_mtd_block_isbad(struct mtd_info *mtd, loff_t offs)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct spinand_device *spinand = nand_to_spinand(nand);
++	struct nand_pos pos;
++	int ret;
++	nanddev_offs_to_pos(nand, offs, &pos);
++	mutex_lock(&spinand->lock);
++	ret = spinand_isbad(nand, &pos);
++	mutex_unlock(&spinand->lock);
++
++	return ret;
++}
++
++static int spinand_markbad(struct nand_device *nand, const struct nand_pos *pos)
++{
++	struct spinand_device *spinand = nand_to_spinand(nand);
++	struct nand_page_io_req req = {
++		.pos = *pos,
++		.ooboffs = 0,
++		.ooblen = 2,
++		.oobbuf.out = spinand->oobbuf,
++	};
++
++	/* Erase block before marking it bad. */
++	spinand_write_enable_op(spinand);
++	spinand_erase_op(spinand, pos);
++	u8 status;
++	spinand_wait(spinand, &status);
++
++	memset(spinand->oobbuf, 0x00, 2);
++	return spinand_write_page(spinand, &req);
++}
++
++
++static int spinand_mtd_block_markbad(struct mtd_info *mtd, loff_t offs)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct spinand_device *spinand = nand_to_spinand(nand);
++	struct nand_pos pos;
++	int ret;
++	nanddev_offs_to_pos(nand, offs, &pos);
++	/*bad block mark the first page*/
++	pos.page=0;
++
++	mutex_lock(&spinand->lock);
++	ret = nanddev_markbad(nand, &pos);
++	mutex_unlock(&spinand->lock);
++
++	return ret;
++}
++
++static int spinand_erase(struct nand_device *nand, const struct nand_pos *pos)
++{
++	struct spinand_device *spinand = nand_to_spinand(nand);
++	u8 status;
++	int ret;
++
++	spinand_write_enable_op(spinand);
++	spinand_erase_op(spinand, pos);
++
++	ret = spinand_wait(spinand, &status);
++
++	if (!ret && (status & STATUS_E_FAIL_MASK) == STATUS_E_FAIL)
++		ret = -EIO;
++
++	if (ret)
++		pr_err("failed to erase block %d (err = %d)\n",
++		       pos->eraseblock, ret);
++
++	return ret;
++}
++
++static int spinand_mtd_erase(struct mtd_info *mtd,
++			     struct erase_info *einfo)
++{
++	struct spinand_device *spinand = mtd_to_spinand(mtd);
++	int ret;
++//	printk("erase block\n");
++	mutex_lock(&spinand->lock);
++	ret = nanddev_mtd_erase(mtd, einfo);
++	mutex_unlock(&spinand->lock);
++
++	//if (!ret)
++	//	mtd_erase_callback(einfo);
++
++	return ret;
++}
++
++static int spinand_mtd_block_isreserved(struct mtd_info *mtd, loff_t offs)
++{
++	struct spinand_device *spinand = mtd_to_spinand(mtd);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct nand_pos pos;
++	int ret;
++
++	nanddev_offs_to_pos(nand, offs, &pos);
++	mutex_lock(&spinand->lock);
++	ret = nanddev_isreserved(nand, &pos);
++	mutex_unlock(&spinand->lock);
++
++	return ret;
++}
++
++static void spinand_set_rd_wr_op(struct spinand_device *spinand)
++{
++	u32 controller_cap = spinand->controller.controller->caps;
++	u32 rw_mode = spinand->rw_mode;
++
++	if ((controller_cap & SPINAND_CAP_RD_QUAD) &&
++	    (rw_mode & SPINAND_RD_QUAD))
++		spinand->read_cache_op = SPINAND_CMD_READ_FROM_CACHE_QUAD_IO;
++	else if ((controller_cap & SPINAND_CAP_RD_X4) &&
++		 (rw_mode & SPINAND_RD_X4))
++		spinand->read_cache_op = SPINAND_CMD_READ_FROM_CACHE_X4;
++	else if ((controller_cap & SPINAND_CAP_RD_DUAL) &&
++		 (rw_mode & SPINAND_RD_DUAL))
++		spinand->read_cache_op = SPINAND_CMD_READ_FROM_CACHE_DUAL_IO;
++	else if ((controller_cap & SPINAND_CAP_RD_X2) &&
++		 (rw_mode & SPINAND_RD_X2))
++		spinand->read_cache_op = SPINAND_CMD_READ_FROM_CACHE_X2;
++	else
++		spinand->read_cache_op = SPINAND_CMD_READ_FROM_CACHE_FAST;
++
++	if ((controller_cap & SPINAND_CAP_WR_X4) &&
++	    (rw_mode & SPINAND_WR_X4))
++		spinand->write_cache_op = SPINAND_CMD_PROG_LOAD_X4;
++	else
++		spinand->write_cache_op = SPINAND_CMD_PROG_LOAD;
++}
++
++static const struct nand_ops spinand_ops = {
++	.erase = spinand_erase,
++	.markbad = spinand_markbad,
++	.isbad = spinand_isbad,
++};
++
++static const struct spinand_manufacturer *spinand_manufacturers[] = {
++	&micron_spinand_manufacturer,
++	&etron_spinand_manufacturer,
++	&giga_spinand_manufacturer,
++	&paragon_spinand_manufacturer,
++};
++
++
++static int spinand_manufacturer_detect(struct spinand_device *spinand)
++{
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(spinand_manufacturers); i++) {
++		if (spinand_manufacturers[i]->ops->detect(spinand)) {
++			spinand->manufacturer.manu = spinand_manufacturers[i];
++
++			return 0;
++		}
++	}
++
++	return -ENODEV;
++}
++
++static int spinand_manufacturer_init(struct spinand_device *spinand)
++{
++	if (spinand->manufacturer.manu->ops->init)
++		return spinand->manufacturer.manu->ops->init(spinand);
++
++	return 0;
++}
++
++static void spinand_manufacturer_cleanup(struct spinand_device *spinand)
++{
++	/* Release manufacturer private data */
++	if (spinand->manufacturer.manu->ops->cleanup)
++		return spinand->manufacturer.manu->ops->cleanup(spinand);
++}
++static int spinand_detect(struct spinand_device *spinand)
++{
++	struct nand_device *nand = &spinand->base;
++	int ret;
++
++	spinand_reset_op(spinand);
++	spinand_read_id_op(spinand, spinand->id.data);
++	spinand->id.len = SPINAND_MAX_ID_LEN;
++
++	ret = spinand_manufacturer_detect(spinand);
++	if (ret) {
++		pr_err("unknown raw ID %*phN\n",
++		       SPINAND_MAX_ID_LEN, spinand->id.data);
++		return ret;
++	}
++
++	pr_info("%s SPI NAND was found.\n", spinand->manufacturer.manu->name);
++	pr_info("%d MiB, block size: %d KiB, page size: %d, OOB size: %d\n",
++		(int)(nanddev_size(nand) >> 20),
++		nanddev_eraseblock_size(nand) >> 10,
++		nanddev_page_size(nand), nanddev_per_page_oobsize(nand));
++	return 0;
++}
++/**
++ * devm_spinand_alloc - [SPI NAND Interface] allocate SPI NAND device instance
++ * @dev: pointer to device model structure
++ */
++struct spinand_device *devm_spinand_alloc(struct device *dev)
++{
++	struct spinand_device *spinand;
++	struct mtd_info *mtd;
++
++	spinand = devm_kzalloc(dev, sizeof(*spinand), GFP_KERNEL);
++	if (!spinand)
++		return ERR_PTR(-ENOMEM);
++
++	spinand_set_of_node(spinand, dev->of_node);
++	mutex_init(&spinand->lock);
++	mtd = spinand_to_mtd(spinand);
++	mtd->dev.parent = dev;
++
++	return spinand;
++}
++EXPORT_SYMBOL_GPL(devm_spinand_alloc);
++static int spinand_read(struct mtd_info *mtd, loff_t from, size_t len,size_t *retlen, u_char *buf)
++{
++	int ret;
++	struct mtd_oob_ops ops = {
++		.len = len,
++		.datbuf = buf,
++	};
++	ret = mtd->_read_oob(mtd, from, &ops);
++	*retlen = ops.retlen;
++
++	if (unlikely(ret < 0))
++		return ret;
++	if (mtd->ecc_strength == 0)
++		return 0;	/* device lacks ecc */
++	return ret >= mtd->bitflip_threshold ? -EUCLEAN : 0;
++}
++
++static int spinand_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,const u_char *buf)
++{
++	struct mtd_oob_ops ops = {
++		.len = len,
++		.datbuf = (u8 *)buf,
++	};
++	int ret;
++
++	ret = mtd->_write_oob(mtd, to, &ops);
++	*retlen = ops.retlen;
++	return ret;
++
++}
++
++int spinand_bbt_create(struct nand_device *nand )
++{
++	unsigned int block=0;
++	unsigned int entry=0;
++	int status=NAND_BBT_BLOCK_STATUS_UNKNOWN;
++	int ret = 0;
++	struct nand_pos pos;
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++	if (nanddev_bbt_is_initialized(nand)) {
++		for(block=0;block < nand->memorg.eraseblocks_per_lun;block++){
++			pos.eraseblock=block;
++			pos.lun=0;
++			pos.page=0;
++			pos.plane=0;
++			pos.target=0;
++			entry = nanddev_bbt_pos_to_entry(nand, &pos);
++			if(nand->ops->isbad(nand, &pos)){
++				printk("found bad block %llx\n",nanddev_pos_to_offs(nand,&pos));
++				ret = nanddev_bbt_set_block_status(nand, entry, NAND_BBT_BLOCK_FACTORY_BAD);
++				ret = nanddev_bbt_update(nand);
++					mtd->ecc_stats.badblocks++;
++				}
++			else{
++				nanddev_bbt_set_block_status(nand, entry, NAND_BBT_BLOCK_GOOD);
++				}
++		}
++
++	}
++		return 0;
++
++}
++int write_test(struct mtd_info *mtd,loff_t to,size_t len)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	size_t retlen;
++	unsigned char *buf;
++	int i=0;
++
++	buf = kzalloc(nanddev_page_size(nand) +
++			       nanddev_per_page_oobsize(nand),
++			       GFP_KERNEL);
++	for(i=0;i<len;i++){
++		buf[i]=i%16;
++	}
++	spinand_write(mtd,to,len,&retlen,buf);
++	kfree(buf);
++	return 0;
++}
++int erase_test(struct mtd_info *mtd,uint64_t  from,uint64_t len)
++{
++	struct erase_info einfo={
++		.mtd=mtd,
++		.addr=from,
++		.len=len,
++		.callback = NULL,
++	};
++
++	spinand_mtd_erase(mtd,&einfo);
++	return 0;
++}
++int read_test(struct mtd_info *mtd,loff_t from,size_t len)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	size_t retlen;
++	unsigned char *buf;
++	int i=0;
++	char en=16;
++	buf = kzalloc(nanddev_page_size(nand) +
++			       nanddev_per_page_oobsize(nand),
++			       GFP_KERNEL);
++	spinand_read(mtd,from,len,&retlen,buf);
++	for(i=0;i<len;i++){
++		if(i%en==0){
++			printk("\n");
++		}
++		printk("%2X  ",buf[i]);
++		if(i==2047)en=8;
++	}
++	kfree(buf);
++	return 0;
++}
++
++int mark_bad_test(struct mtd_info *mtd,loff_t offs)
++{
++	return spinand_mtd_block_markbad(mtd,offs);
++}
++/**
++ * spinand_init - [SPI NAND Interface] initialize the SPI NAND device
++ * @spinand: SPI NAND device structure
++ */
++int spinand_init(struct spinand_device *spinand, struct module *owner)
++{
++	struct mtd_info *mtd = spinand_to_mtd(spinand);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	int ret;
++
++	ret = spinand_detect(spinand);
++	if (ret) {
++		pr_err("Failed to detect a SPI NAND (err = %d).\n", ret);
++		return ret;
++	}
++
++	ret = nanddev_init(nand, &spinand_ops, owner);
++	if (ret)
++		return ret;
++
++	spinand_set_rd_wr_op(spinand);
++
++	/*
++	 * Use kzalloc() instead of devm_kzalloc() here, because some drivers
++	 * may use this buffer for DMA access.
++	 * Memory allocated by devm_ does not guarantee DMA-safe alignment.
++	 */
++	spinand->buf = kzalloc(nanddev_page_size(nand) +
++			       nanddev_per_page_oobsize(nand),
++			       GFP_KERNEL);
++	if (!spinand->buf)
++		return -ENOMEM;
++
++	spinand->oobbuf = spinand->buf + nanddev_page_size(nand);
++
++	ret = spinand_manufacturer_init(spinand);
++	if (ret) {
++		pr_err("Init of SPI NAND failed (err = %d).\n", ret);
++		goto err_free_buf;
++	}
++
++	/*
++	 * Right now, we don't support ECC, so let the whole oob
++	 * area is available for user.
++	 */
++	mtd->_read_oob = spinand_mtd_read;
++	mtd->_write_oob = spinand_mtd_write;
++	mtd->_block_isbad = spinand_mtd_block_isbad;
++	mtd->_block_markbad = spinand_mtd_block_markbad;
++	mtd->_block_isreserved = spinand_mtd_block_isreserved;
++	mtd->_erase = spinand_mtd_erase;
++	mtd->_read = spinand_read;
++	mtd->_write = spinand_write;
++
++	/* After power up, all blocks are locked, so unlock it here. */
++	spinand_lock_block(spinand, BL_ALL_UNLOCKED);
++	/* Right now, we don't support ECC, so disable on-die ECC */
++	//spinand_disable_ecc(spinand);
++	spinand_enable_ecc(spinand);
++
++	return 0;
++
++err_free_buf:
++	kfree(spinand->buf);
++	return ret;
++}
++EXPORT_SYMBOL_GPL(spinand_init);
++/**
++ * spinand_cleanup - clean SPI NAND device
++ * @spinand: SPI NAND device structure
++ */
++void spinand_cleanup(struct spinand_device *spinand)
++{
++	struct nand_device *nand = &spinand->base;
++
++	spinand_manufacturer_cleanup(spinand);
++	kfree(spinand->buf);
++	nanddev_cleanup(nand);
++}
++EXPORT_SYMBOL_GPL(spinand_cleanup);
++
++MODULE_DESCRIPTION("SPI NAND framework");
++MODULE_AUTHOR("Peter Pan<peterpandong@micron.com>");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/etron.c
+@@ -0,0 +1,147 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_ETRON		0xD5
++
++struct etron_spinand_info {
++	char *name;
++	u8 dev_id;
++	struct nand_memory_organization memorg;
++	struct nand_ecc_req eccreq;
++	unsigned int rw_mode;
++};
++
++#define ETRON_SPI_NAND_INFO(nm, did, mo, er, rwm)			\
++	{								\
++		.name = (nm),						\
++		.dev_id = (did),					\
++		.memorg = mo,						\
++		.eccreq = er,						\
++		.rw_mode = (rwm)					\
++	}
++
++static const struct etron_spinand_info etron_spinand_table[] = {
++	ETRON_SPI_NAND_INFO("ETNORxxxx", 0x11,
++			     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
++			     NAND_ECCREQ(8, 512),
++			     SPINAND_RW_COMMON),
++};
++
++static int etron_spinand_get_dummy(struct spinand_device *spinand,
++				    struct spinand_op *op)
++{
++	u8 opcode = op->cmd;
++
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE:
++	case SPINAND_CMD_READ_FROM_CACHE_FAST:
++	case SPINAND_CMD_READ_FROM_CACHE_X2:
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X4:
++	case SPINAND_CMD_READ_ID:
++		return 1;
++
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++		return 2;
++
++	default:
++		return 0;
++	}
++}
++
++/**
++ * etron_spinand_scan_id_table - scan SPI NAND info in id table
++ * @spinand: SPI NAND device structure
++ * @id: point to manufacture id and device id
++ * Description:
++ *   If found in id table, config device with table information.
++ */
++static bool etron_spinand_scan_id_table(struct spinand_device *spinand,
++					 u8 dev_id)
++{
++	struct mtd_info *mtd = spinand_to_mtd(spinand);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct etron_spinand_info *item;
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(etron_spinand_table); i++) {
++		item = (struct etron_spinand_info *)etron_spinand_table + i;
++		if (dev_id != item->dev_id)
++			continue;
++
++		nand->memorg = item->memorg;
++		nand->eccreq = item->eccreq;
++		spinand->rw_mode = item->rw_mode;
++
++		return true;
++	}
++
++	return false;
++}
++
++/**
++ * etron_spinand_detect - initialize device related part in spinand_device
++ * struct if it is Micron device.
++ * @spinand: SPI NAND device structure
++ */
++static bool etron_spinand_detect(struct spinand_device *spinand)
++{
++	u8 *id = spinand->id.data;
++
++	/*
++	 * Micron SPI NAND read ID need a dummy byte,
++	 * so the first byte in raw_id is dummy.
++	 */
++	if (id[1] != SPINAND_MFR_ETRON)
++		return false;
++
++	return etron_spinand_scan_id_table(spinand, id[2]);
++}
++
++/**
++ * etron_spinand_prepare_op - Fix address for cache operation.
++ * @spinand: SPI NAND device structure
++ * @op: pointer to spinand_op struct
++ * @page: page address
++ * @column: column address
++ */
++static void etron_spinand_adjust_cache_op(struct spinand_device *spinand,
++					   const struct nand_page_io_req *req,
++					   struct spinand_op *op)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	unsigned int shift;
++
++	op->n_addr= 2;
++	op->addr[0] = op->addr[1];
++	op->addr[1] = op->addr[2];
++	op->addr[2] = 0;
++	op->dummy_bytes = etron_spinand_get_dummy(spinand, op);
++}
++
++static const struct spinand_manufacturer_ops etron_spinand_manuf_ops = {
++	.detect = etron_spinand_detect,
++	.adjust_cache_op = etron_spinand_adjust_cache_op,
++};
++
++const struct spinand_manufacturer etron_spinand_manufacturer = {
++	.id = SPINAND_MFR_ETRON,
++	.name = "Etron",
++	.ops = &etron_spinand_manuf_ops,
++};
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/micron.c
+@@ -0,0 +1,153 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_MICRON		0x2C
++
++struct micron_spinand_info {
++	char *name;
++	u8 dev_id;
++	struct nand_memory_organization memorg;
++	struct nand_ecc_req eccreq;
++	unsigned int rw_mode;
++};
++
++#define MICRON_SPI_NAND_INFO(nm, did, mo, er, rwm)			\
++	{								\
++		.name = (nm),						\
++		.dev_id = (did),					\
++		.memorg = mo,						\
++		.eccreq = er,						\
++		.rw_mode = (rwm)					\
++	}
++
++static const struct micron_spinand_info micron_spinand_table[] = {
++	MICRON_SPI_NAND_INFO("MT29F2G01ABAGD", 0x24,
++			     NAND_MEMORG(1, 2048, 128, 64, 2048, 2, 1, 1),
++			     NAND_ECCREQ(8, 512),
++			     SPINAND_RW_COMMON),
++};
++
++static int micron_spinand_get_dummy(struct spinand_device *spinand,
++				    struct spinand_op *op)
++{
++	u8 opcode = op->cmd;
++
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE:
++	case SPINAND_CMD_READ_FROM_CACHE_FAST:
++	case SPINAND_CMD_READ_FROM_CACHE_X2:
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X4:
++	case SPINAND_CMD_READ_ID:
++		return 1;
++
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++		return 2;
++
++	default:
++		return 0;
++	}
++}
++
++/**
++ * micron_spinand_scan_id_table - scan SPI NAND info in id table
++ * @spinand: SPI NAND device structure
++ * @id: point to manufacture id and device id
++ * Description:
++ *   If found in id table, config device with table information.
++ */
++static bool micron_spinand_scan_id_table(struct spinand_device *spinand,
++					 u8 dev_id)
++{
++	struct mtd_info *mtd = spinand_to_mtd(spinand);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct micron_spinand_info *item;
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(micron_spinand_table); i++) {
++		item = (struct micron_spinand_info *)micron_spinand_table + i;
++		if (dev_id != item->dev_id)
++			continue;
++
++		nand->memorg = item->memorg;
++		nand->eccreq = item->eccreq;
++		spinand->rw_mode = item->rw_mode;
++
++		return true;
++	}
++
++	return false;
++}
++
++/**
++ * micron_spinand_detect - initialize device related part in spinand_device
++ * struct if it is Micron device.
++ * @spinand: SPI NAND device structure
++ */
++static bool micron_spinand_detect(struct spinand_device *spinand)
++{
++	u8 *id = spinand->id.data;
++
++	/*
++	 * Micron SPI NAND read ID need a dummy byte,
++	 * so the first byte in raw_id is dummy.
++	 */
++	if (id[1] != SPINAND_MFR_MICRON)
++		return false;
++
++	return micron_spinand_scan_id_table(spinand, id[2]);
++}
++
++/**
++ * micron_spinand_prepare_op - Fix address for cache operation.
++ * @spinand: SPI NAND device structure
++ * @op: pointer to spinand_op struct
++ * @page: page address
++ * @column: column address
++ */
++static void micron_spinand_adjust_cache_op(struct spinand_device *spinand,
++					   const struct nand_page_io_req *req,
++					   struct spinand_op *op)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	unsigned int shift;
++
++	/*
++	 * No need to specify the plane number if there's only one plane per
++	 * LUN.
++	 */
++	if (nand->memorg.planes_per_lun < 2)
++		return;
++
++	/* The plane number is passed in MSB just above the column address */
++	shift = fls(nand->memorg.pagesize);
++	op->addr[(16 - shift) / 8] |= req->pos.plane << (shift % 8);
++	op->dummy_bytes = micron_spinand_get_dummy(spinand, op);
++}
++
++static const struct spinand_manufacturer_ops micron_spinand_manuf_ops = {
++	.detect = micron_spinand_detect,
++	.adjust_cache_op = micron_spinand_adjust_cache_op,
++};
++
++const struct spinand_manufacturer micron_spinand_manufacturer = {
++	.id = SPINAND_MFR_MICRON,
++	.name = "Micron",
++	.ops = &micron_spinand_manuf_ops,
++};
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/nand_core.c
+@@ -0,0 +1,213 @@
++/*
++ * Copyright (c) 2017 Free Electrons
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ *
++ * Authors:
++ *	Boris Brezillon <boris.brezillon@free-electrons.com>
++ *	Peter Pan <peterpandong@micron.com>
++ */
++
++#define pr_fmt(fmt)	"nand: " fmt
++
++#include <linux/mtd/nand.h>
++#include <linux/mtd/spinand.h>
++
++bool nanddev_isbad(struct nand_device *nand, const struct nand_pos *pos)
++{
++#if 1
++	if (nanddev_bbt_is_initialized(nand)) {
++		unsigned int entry=0;
++		int status=0;
++
++		entry = nanddev_bbt_pos_to_entry(nand, pos);
++		status = nanddev_bbt_get_block_status(nand, entry);
++		/* Lazy block status retrieval */
++		if (status == NAND_BBT_BLOCK_STATUS_UNKNOWN) {
++			if (nand->ops->isbad(nand, pos))
++				status = NAND_BBT_BLOCK_FACTORY_BAD;
++			else
++				status = NAND_BBT_BLOCK_GOOD;
++
++			nanddev_bbt_set_block_status(nand, entry, status);
++		}
++		//printk("status %llx,%x\n",nanddev_pos_to_offs(nand, pos),status);
++		if (status == NAND_BBT_BLOCK_WORN ||
++		    status == NAND_BBT_BLOCK_FACTORY_BAD)
++			return true;
++
++		return false;
++	}
++#endif
++	return nand->ops->isbad(nand, pos);
++}
++EXPORT_SYMBOL_GPL(nanddev_isbad);
++
++/**
++ * nanddev_markbad - Write a bad block marker to a block
++ * @nand: NAND device
++ * @block: block to mark bad
++ *
++ * Mark a block bad. This function is updating the BBT if available and
++ * calls the low-level markbad hook (nand->ops->markbad()) if
++ * NAND_BBT_NO_OOB_BBM is not set.
++ *
++ * Return: 0 in case of success, a negative error code otherwise.
++ */
++int nanddev_markbad(struct nand_device *nand, const struct nand_pos *pos)
++{
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++	unsigned int entry;
++	int ret = 0;
++	if (nanddev_isbad(nand, pos))
++		return 0;
++
++	ret = nand->ops->markbad(nand, pos);
++	if (ret)
++		pr_warn("failed to write BBM to block @%llx (err = %d)\n",
++			nanddev_pos_to_offs(nand, pos), ret);
++
++	if (!nanddev_bbt_is_initialized(nand))
++		goto out;
++
++	entry = nanddev_bbt_pos_to_entry(nand, pos);
++	ret = nanddev_bbt_set_block_status(nand, entry, NAND_BBT_BLOCK_WORN);
++	if (ret)
++		goto out;
++
++	ret = nanddev_bbt_update(nand);
++
++out:
++	if (!ret)
++		mtd->ecc_stats.badblocks++;
++
++	return ret;
++}
++EXPORT_SYMBOL_GPL(nanddev_markbad);
++
++bool nanddev_isreserved(struct nand_device *nand, const struct nand_pos *pos)
++{
++	unsigned int entry;
++	int status;
++
++	if (!nanddev_bbt_is_initialized(nand))
++		return false;
++
++	/* Return info from the table */
++	entry = nanddev_bbt_pos_to_entry(nand, pos);
++	status = nanddev_bbt_get_block_status(nand, entry);
++	return status == NAND_BBT_BLOCK_RESERVED;
++}
++EXPORT_SYMBOL_GPL(nanddev_isreserved);
++
++/**
++ * nanddev_erase - Erase a NAND portion
++ * @nand: NAND device
++ * @block: eraseblock to erase
++ *
++ * Erase @block block if it's not bad.
++ *
++ * Return: 0 in case of success, a negative error code otherwise.
++ */
++
++int nanddev_erase(struct nand_device *nand, const struct nand_pos *pos)
++{
++	if (nanddev_isbad(nand, pos) || nanddev_isreserved(nand, pos)) {
++		//pr_warn("attempt to erase a bad/reserved block @%llx\n",
++		//	nanddev_pos_to_offs(nand, pos));
++		return -EIO;
++	}
++
++	return nand->ops->erase(nand, pos);
++}
++EXPORT_SYMBOL_GPL(nanddev_erase);
++
++int nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo)
++{
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct nand_pos pos, last;
++	int ret;
++
++	nanddev_offs_to_pos(nand, einfo->addr, &pos);
++	nanddev_offs_to_pos(nand, einfo->addr + einfo->len - 1, &last);
++	while (nanddev_pos_cmp(&pos, &last) <= 0) {
++		ret = nanddev_erase(nand, &pos);
++		if (ret) {
++			einfo->fail_addr = nanddev_pos_to_offs(nand, &pos);
++			einfo->state = MTD_ERASE_FAILED;
++			//printk("erase failed ....\n");
++			return ret;
++		}
++
++		nanddev_pos_next_eraseblock(nand, &pos);
++	}
++
++	einfo->state = MTD_ERASE_DONE;
++
++	return 0;
++}
++EXPORT_SYMBOL_GPL(nanddev_mtd_erase);
++
++/**
++ * nanddev_init - Initialize a NAND device
++ * @nand: NAND device
++ * @memorg: NAND memory organization descriptor
++ * @ops: NAND device operations
++ *
++ * Initialize a NAND device object. Consistency checks are done on @memorg and
++ * @ops.
++ *
++ * Return: 0 in case of success, a negative error code otherwise.
++ */
++int nanddev_init(struct nand_device *nand, const struct nand_ops *ops,
++		 struct module *owner)
++{
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++	struct nand_memory_organization *memorg = nanddev_get_memorg(nand);
++
++	if (!nand || !ops)
++		return -EINVAL;
++
++	if (!ops->erase || !ops->markbad || !ops->isbad)
++		return -EINVAL;
++
++	if (!memorg->bits_per_cell || !memorg->pagesize ||
++	    !memorg->pages_per_eraseblock || !memorg->eraseblocks_per_lun ||
++	    !memorg->planes_per_lun || !memorg->luns_per_target ||
++	    !memorg->ntargets)
++		return -EINVAL;
++
++	nand->rowconv.eraseblock_addr_shift = fls(memorg->pagesize);
++	nand->rowconv.lun_addr_shift = fls(memorg->eraseblocks_per_lun) +
++				       nand->rowconv.eraseblock_addr_shift;
++
++	nand->ops = ops;
++
++	mtd->type = memorg->bits_per_cell == 1 ?
++		    MTD_NANDFLASH : MTD_MLCNANDFLASH;
++	mtd->flags = MTD_CAP_NANDFLASH;
++	mtd->erasesize = memorg->pagesize * memorg->pages_per_eraseblock;
++	mtd->writesize = memorg->pagesize;
++	mtd->writebufsize = memorg->pagesize;
++	mtd->oobsize = memorg->oobsize;
++	mtd->size = nanddev_size(nand);
++	mtd->owner = owner;
++
++	return nanddev_bbt_init(nand);
++}
++EXPORT_SYMBOL_GPL(nanddev_init);
++
++void nanddev_cleanup(struct nand_device *nand)
++{
++	if (nanddev_bbt_is_initialized(nand))
++		nanddev_bbt_cleanup(nand);
++}
++EXPORT_SYMBOL_GPL(nanddev_cleanup);
+--- /dev/null
++++ b/include/linux/mtd/spinand.h
+@@ -0,0 +1,764 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++#ifndef __LINUX_MTD_SPINAND_H
++#define __LINUX_MTD_SPINAND_H
++
++#include <linux/mutex.h>
++#include <linux/bitops.h>
++#include <linux/device.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/nand.h>
++#include <linux/of.h>
++
++/**
++ * Standard SPI NAND flash commands
++ */
++#define SPINAND_CMD_RESET			0xff
++#define SPINAND_CMD_GET_FEATURE			0x0f
++#define SPINAND_CMD_SET_FEATURE			0x1f
++#define SPINAND_CMD_PAGE_READ			0x13
++#define SPINAND_CMD_READ_FROM_CACHE		0x03
++#define SPINAND_CMD_READ_FROM_CACHE_FAST	0x0b
++#define SPINAND_CMD_READ_FROM_CACHE_X2		0x3b
++#define SPINAND_CMD_READ_FROM_CACHE_DUAL_IO	0xbb
++#define SPINAND_CMD_READ_FROM_CACHE_X4		0x6b
++#define SPINAND_CMD_READ_FROM_CACHE_QUAD_IO	0xeb
++#define SPINAND_CMD_BLK_ERASE			0xd8
++#define SPINAND_CMD_PROG_EXC			0x10
++#define SPINAND_CMD_PROG_LOAD			0x02
++#define SPINAND_CMD_PROG_LOAD_RDM_DATA		0x84
++#define SPINAND_CMD_PROG_LOAD_X4		0x32
++#define SPINAND_CMD_PROG_LOAD_RDM_DATA_X4	0x34
++#define SPINAND_CMD_READ_ID			0x9f
++#define SPINAND_CMD_WR_DISABLE			0x04
++#define SPINAND_CMD_WR_ENABLE			0x06
++
++/* feature register */
++#define REG_BLOCK_LOCK		0xa0
++#define REG_CFG			0xb0
++#define REG_STATUS		0xc0
++
++/* status register */
++#define STATUS_OIP_MASK		BIT(0)
++#define STATUS_CRBSY_MASK	BIT(7)
++#define STATUS_READY		0
++#define STATUS_BUSY		BIT(0)
++
++#define STATUS_E_FAIL_MASK	BIT(2)
++#define STATUS_E_FAIL		BIT(2)
++
++#define STATUS_P_FAIL_MASK	BIT(3)
++#define STATUS_P_FAIL		BIT(3)
++
++/* configuration register */
++#define CFG_ECC_MASK		BIT(4)
++#define CFG_ECC_ENABLE		BIT(4)
++
++/* block lock register */
++#define BL_ALL_UNLOCKED		0X00
++
++struct spinand_op;
++struct spinand_device;
++struct nand_device;
++
++/**
++ * struct nand_memory_organization - memory organization structure
++ * @bits_per_cell: number of bits per NAND cell
++ * @pagesize: page size
++ * @oobsize: OOB area size
++ * @pages_per_eraseblock: number of pages per eraseblock
++ * @eraseblocks_per_die: number of eraseblocks per die
++ * @ndies: number of dies
++ */
++struct nand_memory_organization {
++	unsigned int bits_per_cell;
++	unsigned int pagesize;
++	unsigned int oobsize;
++	unsigned int pages_per_eraseblock;
++	unsigned int eraseblocks_per_lun;
++	unsigned int planes_per_lun;
++	unsigned int luns_per_target;
++	unsigned int ntargets;
++};
++
++#define NAND_MEMORG(bpc, ps, os, ppe, epl, ppl, lpt, nt)	\
++	{							\
++		.bits_per_cell = (bpc),				\
++		.pagesize = (ps),				\
++		.oobsize = (os),				\
++		.pages_per_eraseblock = (ppe),			\
++		.eraseblocks_per_lun = (epl),			\
++		.planes_per_lun = (ppl),			\
++		.luns_per_target = (lpt),			\
++		.ntargets = (nt),				\
++	}
++
++/**
++ * struct nand_bbt - bad block table structure
++ * @cache: in memory BBT cache
++ */
++struct nand_bbt {
++	unsigned char *cache;
++};
++
++struct nand_row_converter {
++	unsigned int lun_addr_shift;
++	unsigned int eraseblock_addr_shift;
++};
++
++struct nand_pos {
++	unsigned int target;
++	unsigned int lun;
++	unsigned int plane;
++	unsigned int eraseblock;
++	unsigned int page;
++};
++
++struct nand_page_io_req {
++	struct nand_pos pos;
++	unsigned int dataoffs;
++	unsigned int datalen;
++	union {
++		const void *out;
++		void *in;
++	} databuf;
++	unsigned int ooboffs;
++	unsigned int ooblen;
++	union {
++		const void *out;
++		void *in;
++	} oobbuf;
++};
++/**
++ * struct nand_ops - NAND operations
++ * @erase: erase a specific block
++ * @markbad: mark a specific block bad
++ */
++struct nand_ops {
++	int (*erase)(struct nand_device *nand, const struct nand_pos *pos);
++	int (*markbad)(struct nand_device *nand, const struct nand_pos *pos);
++	bool (*isbad)(struct nand_device *nand, const struct nand_pos *pos);
++};
++
++struct nand_ecc_req {
++	unsigned int strength;
++	unsigned int step_size;
++};
++
++#define NAND_ECCREQ(str, stp) { .strength = (str), .step_size = (stp) }
++
++struct nand_device{
++	struct mtd_info mtd;
++	struct nand_memory_organization memorg;
++	struct nand_ecc_req eccreq;
++	struct nand_row_converter rowconv;
++	struct nand_bbt bbt;
++	const struct nand_ops *ops;
++};
++
++#define SPINAND_MAX_ID_LEN	4
++
++/**
++ * struct spinand_id - SPI NAND id structure
++ * @data: buffer containing the id bytes. Currently 4 bytes large, but can
++ *	  be extended if required.
++ * @len: ID length
++ */
++struct spinand_id {
++	u8 data[SPINAND_MAX_ID_LEN];
++	int len;
++};
++
++/**
++ * struct spinand_controller_ops - SPI NAND controller operations
++ * @exec_op: executute SPI NAND operation
++ */
++struct spinand_controller_ops {
++	int (*exec_op)(struct spinand_device *spinand,
++		       struct spinand_op *op);
++};
++
++
++/**
++ * struct manufacurer_ops - SPI NAND manufacturer specified operations
++ * @detect: detect SPI NAND device, should bot be NULL.
++ *          ->detect() implementation for manufacturer A never sends
++ *          any manufacturer specific SPI command to a SPI NAND from
++ *          manufacturer B, so the proper way is to decode the raw id
++ *          data in spinand->id.data first, if manufacture ID dismatch,
++ *          return directly and let others to detect.
++ * @init: initialize SPI NAND device.
++ * @cleanup: clean SPI NAND device footprint.
++ * @prepare_op: prepara read/write operation.
++ */
++struct spinand_manufacturer_ops {
++	bool (*detect)(struct spinand_device *spinand);
++	int (*init)(struct spinand_device *spinand);
++	void (*cleanup)(struct spinand_device *spinand);
++	void (*adjust_cache_op)(struct spinand_device *spinand,
++				const struct nand_page_io_req *req,
++				struct spinand_op *op);
++};
++
++/**
++ * struct spinand_manufacturer - SPI NAND manufacturer instance
++ * @id: manufacturer ID
++ * @name: manufacturer name
++ * @ops: point to manufacturer operations
++ */
++struct spinand_manufacturer {
++	u8 id;
++	char *name;
++	const struct spinand_manufacturer_ops *ops;
++};
++
++extern const struct spinand_manufacturer micron_spinand_manufacturer;
++extern const struct spinand_manufacturer etron_spinand_manufacturer;
++extern const struct spinand_manufacturer paragon_spinand_manufacturer;
++extern const struct spinand_manufacturer giga_spinand_manufacturer;
++
++#define SPINAND_CAP_RD_X1	BIT(0)
++#define SPINAND_CAP_RD_X2	BIT(1)
++#define SPINAND_CAP_RD_X4	BIT(2)
++#define SPINAND_CAP_RD_DUAL	BIT(3)
++#define SPINAND_CAP_RD_QUAD	BIT(4)
++#define SPINAND_CAP_WR_X1	BIT(5)
++#define SPINAND_CAP_WR_X2	BIT(6)
++#define SPINAND_CAP_WR_X4	BIT(7)
++#define SPINAND_CAP_WR_DUAL	BIT(8)
++#define SPINAND_CAP_WR_QUAD	BIT(9)
++
++/**
++ * struct spinand_controller - SPI NAND controller instance
++ * @ops: point to controller operations
++ * @caps: controller capabilities
++ */
++struct spinand_controller {
++	struct spinand_controller_ops *ops;
++	u32 caps;
++};
++
++/**
++ * struct spinand_device - SPI NAND device instance
++ * @base: NAND device instance
++ * @bbp: internal bad block pattern descriptor
++ * @lock: protection lock
++ * @id: ID structure
++ * @read_cache_op: Opcode of read from cache
++ * @write_cache_op: Opcode of program load
++ * @buf: buffer for read/write data
++ * @oobbuf: buffer for read/write oob
++ * @rw_mode: read/write mode of SPI NAND device
++ * @controller: SPI NAND controller instance
++ * @manufacturer: SPI NAND manufacturer instance, describe
++ *                manufacturer related objects
++ */
++struct spinand_device {
++	struct nand_device base;
++	struct mutex lock;
++	struct spinand_id id;
++	u8 read_cache_op;
++	u8 write_cache_op;
++	u8 *buf;
++	u8 *oobbuf;
++	u32 rw_mode;
++	struct {
++		struct spinand_controller *controller;
++		void *priv;
++	} controller;
++	struct {
++		const struct spinand_manufacturer *manu;
++		void *priv;
++	} manufacturer;
++};
++
++/**
++ * struct nand_io_iter - NAND I/O iterator
++ * @req: current I/O request
++ * @oobbytes_per_page: maximun oob bytes per page
++ * @dataleft: remaining number of data bytes to read/write
++ * @oobleft: remaining number of OOB bytes to read/write
++ */
++struct nand_io_iter {
++	struct nand_page_io_req req;
++	unsigned int oobbytes_per_page;
++	unsigned int dataleft;
++	unsigned int oobleft;
++};
++
++/**
++ * mtd_to_nanddev - Get the NAND device attached to the MTD instance
++ * @mtd: MTD instance
++ *
++ * Return: the NAND device embedding @mtd.
++ */
++static inline struct nand_device *mtd_to_nanddev(struct mtd_info *mtd)
++{
++	return container_of(mtd, struct nand_device, mtd);
++}
++/**
++ * nanddev_to_mtd - Get the MTD device attached to a NAND device
++ * @nand: NAND device
++ *
++ * Return: the MTD device embedded in @nand.
++ */
++static inline struct mtd_info *nanddev_to_mtd(struct nand_device *nand)
++{
++	return &nand->mtd;
++}
++
++/**
++ * mtd_to_spinand - Get the SPI NAND device attached to the MTD instance
++ * @mtd: MTD instance
++ *
++ * Returns the SPI NAND device attached to @mtd.
++ */
++static inline struct spinand_device *mtd_to_spinand(struct mtd_info *mtd)
++{
++	return container_of(mtd_to_nanddev(mtd), struct spinand_device, base);
++}
++
++/**
++ * spinand_to_mtd - Get the MTD device attached to the SPI NAND device
++ * @spinand: SPI NAND device
++ *
++ * Returns the MTD device attached to @spinand.
++ */
++static inline struct mtd_info *spinand_to_mtd(struct spinand_device *spinand)
++{
++	return nanddev_to_mtd(&spinand->base);
++}
++
++/**
++ * nand_to_spinand - Get the SPI NAND device embedding an NAND object
++ * @nand: NAND object
++ *
++ * Returns the SPI NAND device embedding @nand.
++ */
++static inline struct spinand_device *nand_to_spinand(struct nand_device *nand)
++{
++	return container_of(nand, struct spinand_device, base);
++}
++
++/**
++ * spinand_to_nand - Get the NAND device embedded in a SPI NAND object
++ * @spinand: SPI NAND device
++ *
++ * Returns the NAND device embedded in @spinand.
++ */
++static inline struct nand_device *
++spinand_to_nand(struct spinand_device *spinand)
++{
++	return &spinand->base;
++}
++
++/**
++ * nanddev_set_of_node - Attach a DT node to a NAND device
++ * @nand: NAND device
++ * @np: DT node
++ *
++ * Attach a DT node to a NAND device.
++ */
++static inline void nanddev_set_of_node(struct nand_device *nand,
++				       struct device_node *np)
++{
++	mtd_set_of_node(&nand->mtd, np);
++}
++
++/**
++ * spinand_set_of_node - Attach a DT node to a SPI NAND device
++ * @spinand: SPI NAND device
++ * @np: DT node
++ *
++ * Attach a DT node to a SPI NAND device.
++ */
++static inline void spinand_set_of_node(struct spinand_device *spinand,
++				       struct device_node *np)
++{
++	nanddev_set_of_node(&spinand->base, np);
++}
++
++#define SPINAND_MAX_ADDR_LEN	4
++
++/**
++ * struct spinand_op - SPI NAND operation description
++ * @cmd: opcode to send
++ * @n_addr: address bytes
++ * @addr_nbits: number of bit used to transfer address
++ * @dummy_types: dummy bytes followed address
++ * @addr: address or dummy bytes buffer
++ * @n_tx: size of tx_buf
++ * @tx_buf: data to be written
++ * @n_rx: size of rx_buf
++ * @rx_buf: data to be read
++ * @data_nbits: number of bit used to transfer data
++ */
++struct spinand_op {
++	u8 cmd;
++	u8 n_addr;
++	u8 addr_nbits;
++	u8 dummy_bytes;
++	u8 addr[SPINAND_MAX_ADDR_LEN];
++	u32 n_tx;
++	const u8 *tx_buf;
++	u32 n_rx;
++	u8 *rx_buf;
++	u8 data_nbits;
++};
++/**
++ * nanddev_neraseblocks - Get the total number of erasablocks
++ * @nand: NAND device
++ *
++ * Return: the number of eraseblocks exposed by @nand.
++ */
++static inline unsigned int nanddev_neraseblocks(const struct nand_device *nand)
++{
++	return (u64)nand->memorg.luns_per_target *
++	       nand->memorg.eraseblocks_per_lun *
++	        nand->memorg.ntargets;
++}
++
++/* BBT related functions */
++enum nand_bbt_block_status {
++	NAND_BBT_BLOCK_STATUS_UNKNOWN,
++	NAND_BBT_BLOCK_GOOD,
++	NAND_BBT_BLOCK_WORN,
++	NAND_BBT_BLOCK_RESERVED,
++	NAND_BBT_BLOCK_FACTORY_BAD,
++	NAND_BBT_BLOCK_NUM_STATUS,
++};
++int nanddev_bbt_init(struct nand_device *nand);
++void nanddev_bbt_cleanup(struct nand_device *nand);
++int nanddev_bbt_update(struct nand_device *nand);
++int nanddev_bbt_get_block_status(const struct nand_device *nand,
++				 unsigned int entry);
++int nanddev_bbt_set_block_status(struct nand_device *nand, unsigned int entry,
++				 enum nand_bbt_block_status status);
++
++/* SPI NAND supported OP mode */
++#define SPINAND_RD_X1		BIT(0)
++#define SPINAND_RD_X2		BIT(1)
++#define SPINAND_RD_X4		BIT(2)
++#define SPINAND_RD_DUAL		BIT(3)
++#define SPINAND_RD_QUAD		BIT(4)
++#define SPINAND_WR_X1		BIT(5)
++#define SPINAND_WR_X2		BIT(6)
++#define SPINAND_WR_X4		BIT(7)
++#define SPINAND_WR_DUAL		BIT(8)
++#define SPINAND_WR_QUAD		BIT(9)
++
++#define SPINAND_RD_COMMON	(SPINAND_RD_X1 | SPINAND_RD_X2 | \
++				 SPINAND_RD_X4 | SPINAND_RD_DUAL | \
++				 SPINAND_RD_QUAD)
++#define SPINAND_WR_COMMON	(SPINAND_WR_X1 | SPINAND_WR_X4)
++#define SPINAND_RW_COMMON	(SPINAND_RD_COMMON | SPINAND_WR_COMMON)
++
++struct spinand_device *devm_spinand_alloc(struct device *dev);
++int spinand_init(struct spinand_device *spinand, struct module *owner);
++void spinand_cleanup(struct spinand_device *spinand);
++
++/**
++ * nanddev_page_size - Get NAND page size
++ * @nand: NAND device
++ *
++ * Return: the page size.
++ */
++static inline size_t nanddev_page_size(const struct nand_device *nand)
++{
++	return nand->memorg.pagesize;
++}
++
++/**
++ * nanddev_per_page_oobsize - Get NAND OOB size
++ * @nand: NAND device
++ *
++ * Return: the OOB size.
++ */
++static inline unsigned int
++nanddev_per_page_oobsize(const struct nand_device *nand)
++{
++	return nand->memorg.oobsize;
++}
++
++/**
++ * nanddev_pages_per_eraseblock - Get the number of pages per eraseblock
++ * @nand: NAND device
++ *
++ * Return: the number of pages per eraseblock.
++ */
++static inline unsigned int
++nanddev_pages_per_eraseblock(const struct nand_device *nand)
++{
++	return nand->memorg.pages_per_eraseblock;
++}
++
++/**
++ * nanddev_per_page_oobsize - Get NAND erase block size
++ * @nand: NAND device
++ *
++ * Return: the eraseblock size.
++ */
++static inline size_t nanddev_eraseblock_size(const struct nand_device *nand)
++{
++	return nand->memorg.pagesize * nand->memorg.pages_per_eraseblock;
++}
++
++static inline u64 nanddev_target_size(const struct nand_device *nand)
++{
++	return (u64)nand->memorg.luns_per_target *
++	       nand->memorg.eraseblocks_per_lun *
++	       nand->memorg.pages_per_eraseblock *
++	       nand->memorg.pagesize;
++}
++
++/**
++ * nanddev_ntarget - Get the total of targets
++ * @nand: NAND device
++ *
++ * Return: the number of dies exposed by @nand.
++ */
++static inline unsigned int nanddev_ntargets(const struct nand_device *nand)
++{
++	return nand->memorg.ntargets;
++}
++
++/**
++ * nanddev_size - Get NAND size
++ * @nand: NAND device
++ *
++ * Return: the total size exposed of @nand.
++ */
++static inline u64 nanddev_size(const struct nand_device *nand)
++{
++	return nanddev_target_size(nand) * nanddev_ntargets(nand);
++}
++
++/**
++ * nanddev_get_memorg - Extract memory organization info from a NAND device
++ * @nand: NAND device
++ *
++ * This can be used by the upper layer to fill the memorg info before calling
++ * nanddev_init().
++ *
++ * Return: the memorg object embedded in the NAND device.
++ */
++static inline struct nand_memory_organization *
++nanddev_get_memorg(struct nand_device *nand)
++{
++	return &nand->memorg;
++}
++
++
++static inline unsigned int nanddev_pos_to_row(struct nand_device *nand,
++					      const struct nand_pos *pos)
++{
++	return (pos->lun << nand->rowconv.lun_addr_shift) |
++	       (pos->eraseblock << nand->rowconv.eraseblock_addr_shift) |
++	       pos->page;
++}
++
++
++static inline unsigned int nanddev_offs_to_pos(struct nand_device *nand,
++					       loff_t offs,
++					       struct nand_pos *pos)
++{
++	unsigned int pageoffs;
++	u64 tmp = offs;
++
++	pageoffs = do_div(tmp, nand->memorg.pagesize);
++	pos->page = do_div(tmp, nand->memorg.pages_per_eraseblock);
++	pos->eraseblock = do_div(tmp, nand->memorg.eraseblocks_per_lun);
++	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
++	pos->lun = do_div(tmp, nand->memorg.luns_per_target);
++	pos->target = tmp;
++
++	return pageoffs;
++}
++
++static inline int nanddev_pos_cmp(const struct nand_pos *a,
++				  const struct nand_pos *b)
++{
++	if (a->target != b->target)
++		return a->target < b->target ? -1 : 1;
++
++	if (a->lun != b->lun)
++		return a->lun < b->lun ? -1 : 1;
++
++	if (a->eraseblock != b->eraseblock)
++		return a->eraseblock < b->eraseblock ? -1 : 1;
++
++	if (a->page != b->page)
++		return a->page < b->page ? -1 : 1;
++
++	return 0;
++}
++
++static inline void nanddev_pos_next_target(struct nand_device *nand,
++					   struct nand_pos *pos)
++{
++	pos->page = 0;
++	pos->plane = 0;
++	pos->eraseblock = 0;
++	pos->lun = 0;
++	pos->target++;
++}
++
++static inline void nanddev_pos_next_lun(struct nand_device *nand,
++					struct nand_pos *pos)
++{
++	if (pos->lun >= nand->memorg.luns_per_target - 1)
++		return nanddev_pos_next_target(nand, pos);
++
++	pos->lun++;
++	pos->page = 0;
++	pos->plane = 0;
++	pos->eraseblock = 0;
++}
++
++static inline void nanddev_pos_next_eraseblock(struct nand_device *nand,
++					       struct nand_pos *pos)
++{
++	if (pos->eraseblock >= nand->memorg.eraseblocks_per_lun - 1)
++		return nanddev_pos_next_lun(nand, pos);
++
++	pos->eraseblock++;
++	pos->page = 0;
++	pos->plane = pos->eraseblock % nand->memorg.planes_per_lun;
++}
++
++static inline loff_t nanddev_pos_to_offs(struct nand_device *nand,
++					 const struct nand_pos *pos)
++{
++	unsigned int npages;
++
++	npages = pos->page +
++		 ((pos->eraseblock +
++		   (pos->lun +
++		    (pos->target * nand->memorg.luns_per_target)) *
++		   nand->memorg.eraseblocks_per_lun) *
++		  nand->memorg.pages_per_eraseblock);
++
++	return (loff_t)npages * nand->memorg.pagesize;
++}
++
++static inline void nanddev_pos_next_page(struct nand_device *nand,
++					 struct nand_pos *pos)
++{
++	if (pos->page >= nand->memorg.pages_per_eraseblock - 1)
++		return nanddev_pos_next_eraseblock(nand, pos);
++
++	pos->page++;
++}
++
++/**
++ * nand_io_iter_init - Initialize a NAND I/O iterator
++ * @nand: NAND device
++ * @offs: absolute offset
++ * @req: MTD request
++ * @iter: page iterator
++ */
++static inline void nanddev_io_iter_init(struct nand_device *nand,
++					loff_t offs, struct mtd_oob_ops *req,
++					struct nand_io_iter *iter)
++{
++	struct mtd_info *mtd = nanddev_to_mtd(nand);
++
++	iter->req.dataoffs = nanddev_offs_to_pos(nand, offs, &iter->req.pos);
++	iter->req.ooboffs = req->ooboffs;
++	iter->oobbytes_per_page = mtd_oobavail(mtd, req);
++	iter->dataleft = req->len;
++	iter->oobleft = req->ooblen;
++	iter->req.databuf.in = req->datbuf;
++	iter->req.datalen = min_t(unsigned int,
++				  nand->memorg.pagesize - iter->req.dataoffs,
++				  iter->dataleft);
++	iter->req.oobbuf.in = req->oobbuf;
++	iter->req.ooblen = min_t(unsigned int,
++				 iter->oobbytes_per_page - iter->req.ooboffs,
++				 iter->oobleft);
++}
++
++/**
++ * nand_io_iter_next_page - Move to the next page
++ * @nand: NAND device
++ * @iter: page iterator
++ */
++static inline void nanddev_io_iter_next_page(struct nand_device *nand,
++					     struct nand_io_iter *iter)
++{
++	nanddev_pos_next_page(nand, &iter->req.pos);
++	iter->dataleft -= iter->req.datalen;
++	iter->req.databuf.in += iter->req.datalen;
++	iter->oobleft -= iter->req.ooblen;
++	iter->req.oobbuf.in += iter->req.ooblen;
++	iter->req.dataoffs = 0;
++	iter->req.ooboffs = 0;
++	iter->req.datalen = min_t(unsigned int, nand->memorg.pagesize,
++				  iter->dataleft);
++	iter->req.ooblen = min_t(unsigned int, iter->oobbytes_per_page,
++				 iter->oobleft);
++}
++
++/**
++ * nand_io_iter_end - Should end iteration or not
++ * @nand: NAND device
++ * @iter: page iterator
++ */
++static inline bool nanddev_io_iter_end(struct nand_device *nand,
++				       const struct nand_io_iter *iter)
++{
++	if (iter->dataleft || iter->oobleft)
++		return false;
++
++	return true;
++}
++
++/**
++ * nand_io_for_each_page - Iterate over all NAND pages contained in an MTD I/O
++ *			   request
++ * @nand: NAND device
++ * @start: start address to read/write
++ * @req: MTD I/O request
++ * @iter: page iterator
++ */
++#define nanddev_io_for_each_page(nand, start, req, iter)		\
++	for (nanddev_io_iter_init(nand, start, req, iter);		\
++	     !nanddev_io_iter_end(nand, iter);				\
++	     nanddev_io_iter_next_page(nand, iter))
++
++static inline unsigned int nanddev_bbt_pos_to_entry(struct nand_device *nand,
++						    const struct nand_pos *pos)
++{
++	return pos->eraseblock;
++}
++
++static inline bool nanddev_bbt_is_initialized(struct nand_device *nand)
++{
++	return !!nand->bbt.cache;
++}
++
++int nanddev_init(struct nand_device *nand, const struct nand_ops *ops,
++		 struct module *owner);
++void nanddev_cleanup(struct nand_device *nand);
++bool nanddev_isbad(struct nand_device *nand, const struct nand_pos *pos);
++bool nanddev_isreserved(struct nand_device *nand, const struct nand_pos *pos);
++int nanddev_erase(struct nand_device *nand, const struct nand_pos *pos);
++int nanddev_markbad(struct nand_device *nand, const struct nand_pos *pos);
++
++/* MTD -> NAND helper functions. */
++int nanddev_mtd_erase(struct mtd_info *mtd, struct erase_info *einfo);
++
++
++#endif /* __LINUX_MTD_SPINAND_H */
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/generic-spinand-controller.c
+@@ -0,0 +1,182 @@
++/*
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++#include <linux/kernel.h>
++#include <linux/module.h>
++#include <linux/spi/spi.h>
++#include <linux/mtd/mtd.h>
++#include <linux/mtd/spinand.h>
++
++struct gen_spinand_controller {
++	struct spinand_controller ctrl;
++	struct spi_device *spi;
++};
++
++#define to_gen_spinand_controller(c) \
++	container_of(c, struct gen_spinand_controller, ctrl)
++
++/*
++ * gen_spinand_controller_exec_op - to process a command to send to the
++ * SPI NAND by generic SPI bus
++ * @spinand: SPI NAND device structure
++ * @op: SPI NAND operation descriptor
++ */
++static int gen_spinand_controller_exec_op(struct spinand_device *spinand,
++				   struct spinand_op *op)
++{
++	struct spi_message message;
++	struct spi_transfer x[3];
++	struct spinand_controller *spinand_controller;
++	struct gen_spinand_controller *controller;
++
++	spinand_controller = spinand->controller.controller;
++	controller = to_gen_spinand_controller(spinand_controller);
++	spi_message_init(&message);
++	memset(x, 0, sizeof(x));
++	x[0].len = 1;
++	x[0].tx_nbits = 1;
++	x[0].tx_buf = &op->cmd;
++	spi_message_add_tail(&x[0], &message);
++
++	if (op->n_addr + op->dummy_bytes) {
++		x[1].len = op->n_addr + op->dummy_bytes;
++		x[1].tx_nbits = op->addr_nbits;
++		x[1].tx_buf = op->addr;
++		//printk("cmd:%2X,naddr:%d,[%2X][%2X][%2X]\n",op->cmd,op->n_addr,op->addr[0],op->addr[1],op->addr[2]);
++		spi_message_add_tail(&x[1], &message);
++	}
++
++	if (op->n_tx) {
++		x[2].len = op->n_tx;
++		x[2].tx_nbits = op->data_nbits;
++		x[2].tx_buf = op->tx_buf;
++		spi_message_add_tail(&x[2], &message);
++	} else if (op->n_rx) {
++		x[2].len = op->n_rx;
++		x[2].rx_nbits = op->data_nbits;
++		x[2].rx_buf = op->rx_buf;
++		spi_message_add_tail(&x[2], &message);
++	}
++
++	return spi_sync(controller->spi, &message);
++}
++
++static struct spinand_controller_ops gen_spinand_controller_ops = {
++	.exec_op = gen_spinand_controller_exec_op,
++};
++extern int read_test(struct mtd_info *mtd,loff_t from,size_t len);
++extern int erase_test(struct mtd_info *mtd,uint64_t  from,uint64_t len);
++extern int write_test(struct mtd_info *mtd,loff_t to,size_t len);
++extern int spinand_bbt_create(struct nand_device *nand );
++extern int mark_bad_test(struct mtd_info *mtd,loff_t offs);
++static int gen_spinand_controller_probe(struct spi_device *spi)
++{
++	struct spinand_device *spinand;
++	struct gen_spinand_controller *controller;
++	struct spinand_controller *spinand_controller;
++	struct device *dev = &spi->dev;
++	u16 mode = spi->mode;
++	int ret;
++
++	spinand = devm_spinand_alloc(dev);
++	if (IS_ERR(spinand)) {
++		ret = PTR_ERR(spinand);
++		goto out;
++	}
++
++	controller = devm_kzalloc(dev, sizeof(*controller), GFP_KERNEL);
++	if (!controller) {
++		ret = -ENOMEM;
++		goto out;
++	}
++
++	controller->spi = spi;
++	spinand_controller = &controller->ctrl;
++	spinand_controller->ops = &gen_spinand_controller_ops;
++	spinand_controller->caps = SPINAND_CAP_RD_X1 | SPINAND_CAP_WR_X1;
++
++	if ((mode & SPI_RX_QUAD) && (mode & SPI_TX_QUAD))
++		spinand_controller->caps |= SPINAND_CAP_RD_QUAD;
++
++	if ((mode & SPI_RX_DUAL) && (mode & SPI_TX_DUAL))
++		spinand_controller->caps |= SPINAND_CAP_RD_DUAL;
++
++	if (mode & SPI_RX_QUAD)
++		spinand_controller->caps |= SPINAND_CAP_RD_X4;
++
++	if (mode & SPI_RX_DUAL)
++		spinand_controller->caps |= SPINAND_CAP_RD_X2;
++
++	if (mode & SPI_TX_QUAD)
++		spinand_controller->caps |= SPINAND_CAP_WR_QUAD |
++					    SPINAND_CAP_WR_X4;
++
++	if (mode & SPI_TX_DUAL)
++		spinand_controller->caps |= SPINAND_CAP_WR_DUAL |
++					    SPINAND_CAP_WR_X2;
++
++	spinand->controller.controller = spinand_controller;
++	spi_set_drvdata(spi, spinand);
++
++	ret = spinand_init(spinand, THIS_MODULE);
++	if (ret)
++		goto out;
++
++	ret = mtd_device_register(spinand_to_mtd(spinand), NULL, 0);
++	struct nand_device *nand =spinand_to_nand(spinand);
++	spinand_bbt_create(nand);
++	//mark_bad_test(spinand_to_mtd(spinand),0x00);
++	/*
++	int i=0,status=0;
++	unsigned int entry=0;
++	struct nand_pos pos;
++	for(i=0;i<1024;i++){
++
++		erase_test(spinand_to_mtd(spinand),i*0x20000,0x20000);
++		}*/
++	//erase_test(spinand_to_mtd(spinand),0x00,0x20000);
++	//write_test(spinand_to_mtd(spinand),0x00,2048);
++	//read_test(spinand_to_mtd(spinand),0x00,2048);
++	//mark_bad_test(spinand_to_mtd(spinand),0);
++	//read_test(spinand_to_mtd(spinand),0x00,2048);
++out:
++	return ret;
++}
++
++static int gen_spinand_controller_remove(struct spi_device *spi)
++{
++	struct spinand_device *spinand = spi_get_drvdata(spi);
++	int ret;
++
++	ret = mtd_device_unregister(spinand_to_mtd(spinand));
++	if (ret)
++		return ret;
++
++	spinand_cleanup(spinand);
++
++	return 0;
++}
++
++static struct spi_driver gen_spinand_controller_driver = {
++	.driver = {
++		.name	= "generic-spinand-controller",
++		.owner	= THIS_MODULE,
++	},
++	.probe	= gen_spinand_controller_probe,
++	.remove	= gen_spinand_controller_remove,
++};
++module_spi_driver(gen_spinand_controller_driver);
++
++MODULE_DESCRIPTION("Generic SPI NAND controller");
++MODULE_AUTHOR("Peter Pan <peterpandong@micron.com>");
++MODULE_LICENSE("GPL v2");
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/gigadevice.c
+@@ -0,0 +1,142 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_GIGA		0xC8
++
++struct giga_spinand_info {
++	char *name;
++	u8 dev_id;
++	struct nand_memory_organization memorg;
++	struct nand_ecc_req eccreq;
++	unsigned int rw_mode;
++};
++
++#define GIGA_SPI_NAND_INFO(nm, did, mo, er, rwm)			\
++	{								\
++		.name = (nm),						\
++		.dev_id = (did),					\
++		.memorg = mo,						\
++		.eccreq = er,						\
++		.rw_mode = (rwm)					\
++	}
++
++static const struct giga_spinand_info giga_spinand_table[] = {
++	GIGA_SPI_NAND_INFO("GIGAxxxx", 0xB1,
++			     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
++			     NAND_ECCREQ(8, 512),
++			     SPINAND_RW_COMMON),
++};
++
++static int giga_spinand_get_dummy(struct spinand_device *spinand,
++				    struct spinand_op *op)
++{
++	u8 opcode = op->cmd;
++
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE_FAST:
++	case SPINAND_CMD_READ_FROM_CACHE:
++	case SPINAND_CMD_READ_FROM_CACHE_X2:
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X4:
++	case SPINAND_CMD_READ_ID:
++		return 1;
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++		return 2;
++
++	default:
++		return 0;
++	}
++}
++
++/**
++ * giga_spinand_scan_id_table - scan SPI NAND info in id table
++ * @spinand: SPI NAND device structure
++ * @id: point to manufacture id and device id
++ * Description:
++ *   If found in id table, config device with table information.
++ */
++static bool giga_spinand_scan_id_table(struct spinand_device *spinand,
++					 u8 dev_id)
++{
++	struct mtd_info *mtd = spinand_to_mtd(spinand);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct giga_spinand_info *item;
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(giga_spinand_table); i++) {
++		item = (struct giga_spinand_info *)giga_spinand_table + i;
++		if (dev_id != item->dev_id)
++			continue;
++
++		nand->memorg = item->memorg;
++		nand->eccreq = item->eccreq;
++		spinand->rw_mode = item->rw_mode;
++
++		return true;
++	}
++
++	return false;
++}
++
++/**
++ * giga_spinand_detect - initialize device related part in spinand_device
++ * struct if it is Micron device.
++ * @spinand: SPI NAND device structure
++ */
++static bool giga_spinand_detect(struct spinand_device *spinand)
++{
++	u8 *id = spinand->id.data;
++
++	/*
++	 * Micron SPI NAND read ID need a dummy byte,
++	 * so the first byte in raw_id is dummy.
++	 */
++	if (id[0] != SPINAND_MFR_GIGA)
++		return false;
++
++	return giga_spinand_scan_id_table(spinand, id[1]);
++}
++
++/**
++ * giga_spinand_prepare_op - Fix address for cache operation.
++ * @spinand: SPI NAND device structure
++ * @op: pointer to spinand_op struct
++ * @page: page address
++ * @column: column address
++ */
++static void giga_spinand_adjust_cache_op(struct spinand_device *spinand,
++					   const struct nand_page_io_req *req,
++					   struct spinand_op *op)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	unsigned int shift;
++
++	op->dummy_bytes = giga_spinand_get_dummy(spinand, op);
++}
++
++static const struct spinand_manufacturer_ops giga_spinand_manuf_ops = {
++	.detect = giga_spinand_detect,
++	.adjust_cache_op = giga_spinand_adjust_cache_op,
++};
++
++const struct spinand_manufacturer giga_spinand_manufacturer = {
++	.id = SPINAND_MFR_GIGA,
++	.name = "Giga",
++	.ops = &giga_spinand_manuf_ops,
++};
+--- /dev/null
++++ b/drivers/mtd/nand/spi_nand/paragon.c
+@@ -0,0 +1,147 @@
++/*
++ *
++ * Copyright (c) 2016-2017 Micron Technology, Inc.
++ *
++ * This program is free software; you can redistribute it and/or
++ * modify it under the terms of the GNU General Public License
++ * as published by the Free Software Foundation; either version 2
++ * of the License, or (at your option) any later version.
++ *
++ * This program is distributed in the hope that it will be useful,
++ * but WITHOUT ANY WARRANTY; without even the implied warranty of
++ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++ * GNU General Public License for more details.
++ */
++
++#include <linux/device.h>
++#include <linux/kernel.h>
++#include <linux/mtd/spinand.h>
++
++#define SPINAND_MFR_PARAGON		0xA1
++
++struct paragon_spinand_info {
++	char *name;
++	u8 dev_id;
++	struct nand_memory_organization memorg;
++	struct nand_ecc_req eccreq;
++	unsigned int rw_mode;
++};
++
++#define PARAGON_SPI_NAND_INFO(nm, did, mo, er, rwm)			\
++	{								\
++		.name = (nm),						\
++		.dev_id = (did),					\
++		.memorg = mo,						\
++		.eccreq = er,						\
++		.rw_mode = (rwm)					\
++	}
++
++static const struct paragon_spinand_info paragon_spinand_table[] = {
++	PARAGON_SPI_NAND_INFO("PARAGONxxxx", 0xe1,
++			     NAND_MEMORG(1, 2048, 128, 64, 1024, 1, 1, 1),
++			     NAND_ECCREQ(8, 512),
++			     SPINAND_RW_COMMON),
++};
++
++static int paragon_spinand_get_dummy(struct spinand_device *spinand,
++				    struct spinand_op *op)
++{
++	u8 opcode = op->cmd;
++
++	switch (opcode) {
++	case SPINAND_CMD_READ_FROM_CACHE_FAST:
++	case SPINAND_CMD_READ_FROM_CACHE:
++	case SPINAND_CMD_READ_FROM_CACHE_X2:
++	case SPINAND_CMD_READ_FROM_CACHE_DUAL_IO:
++	case SPINAND_CMD_READ_FROM_CACHE_X4:
++	case SPINAND_CMD_READ_ID:
++		return 1;
++
++	case SPINAND_CMD_READ_FROM_CACHE_QUAD_IO:
++		return 2;
++
++	default:
++		return 0;
++	}
++}
++
++/**
++ * paragon_spinand_scan_id_table - scan SPI NAND info in id table
++ * @spinand: SPI NAND device structure
++ * @id: point to manufacture id and device id
++ * Description:
++ *   If found in id table, config device with table information.
++ */
++static bool paragon_spinand_scan_id_table(struct spinand_device *spinand,
++					 u8 dev_id)
++{
++	struct mtd_info *mtd = spinand_to_mtd(spinand);
++	struct nand_device *nand = mtd_to_nanddev(mtd);
++	struct paragon_spinand_info *item;
++	unsigned int i;
++
++	for (i = 0; i < ARRAY_SIZE(paragon_spinand_table); i++) {
++		item = (struct paragon_spinand_info *)paragon_spinand_table + i;
++		if (dev_id != item->dev_id)
++			continue;
++
++		nand->memorg = item->memorg;
++		nand->eccreq = item->eccreq;
++		spinand->rw_mode = item->rw_mode;
++
++		return true;
++	}
++
++	return false;
++}
++
++/**
++ * paragon_spinand_detect - initialize device related part in spinand_device
++ * struct if it is Micron device.
++ * @spinand: SPI NAND device structure
++ */
++static bool paragon_spinand_detect(struct spinand_device *spinand)
++{
++	u8 *id = spinand->id.data;
++
++	/*
++	 * Micron SPI NAND read ID need a dummy byte,
++	 * so the first byte in raw_id is dummy.
++	 */
++	if (id[1] != SPINAND_MFR_PARAGON)
++		return false;
++
++	return paragon_spinand_scan_id_table(spinand, id[2]);
++}
++
++/**
++ * paragon_spinand_prepare_op - Fix address for cache operation.
++ * @spinand: SPI NAND device structure
++ * @op: pointer to spinand_op struct
++ * @page: page address
++ * @column: column address
++ */
++static void paragon_spinand_adjust_cache_op(struct spinand_device *spinand,
++					   const struct nand_page_io_req *req,
++					   struct spinand_op *op)
++{
++	struct nand_device *nand = spinand_to_nand(spinand);
++	unsigned int shift;
++
++	op->n_addr= 2;
++	op->addr[0] = op->addr[1];
++	op->addr[1] = op->addr[2];
++	op->addr[2] = 0;
++	op->dummy_bytes = paragon_spinand_get_dummy(spinand, op);
++}
++
++static const struct spinand_manufacturer_ops paragon_spinand_manuf_ops = {
++	.detect = paragon_spinand_detect,
++	.adjust_cache_op = paragon_spinand_adjust_cache_op,
++};
++
++const struct spinand_manufacturer paragon_spinand_manufacturer = {
++	.id = SPINAND_MFR_PARAGON,
++	.name = "Paragon",
++	.ops = &paragon_spinand_manuf_ops,
++};
diff --git a/target/linux/ar71xx/patches-4.9/742-add-modem-driver.patch b/target/linux/ar71xx/patches-4.9/742-add-modem-driver.patch
new file mode 100644
index 0000000..f3444a3
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.9/742-add-modem-driver.patch
@@ -0,0 +1,250 @@
+--- a/drivers/net/usb/qmi_wwan.c
++++ b/drivers/net/usb/qmi_wwan.c
+@@ -155,6 +155,24 @@ static const u8 default_modem_addr[ETH_A
+ 
+ static const u8 buggy_fw_addr[ETH_ALEN] = {0x00, 0xa0, 0xc6, 0x00, 0x00, 0x00};
+ 
++#if 1 //Added by Quectel
++#include <linux/etherdevice.h>
++struct sk_buff *qmi_wwan_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
++{
++	if (dev->udev->descriptor.idVendor != cpu_to_le16(0x2C7C))
++		return skb;
++	// Skip Ethernet header from message
++	if (skb_pull(skb, ETH_HLEN)) {
++		return skb;
++	} else {
++		dev_err(&dev->intf->dev, "Packet Dropped ");
++	}
++	// Filter the packet out, release it
++	dev_kfree_skb_any(skb);
++	return NULL;
++}
++#endif
++
+ /* Make up an ethernet header if the packet doesn't have one.
+  *
+  * A firmware bug common among several devices cause them to send raw
+@@ -445,6 +463,20 @@ static int qmi_wwan_bind(struct usbnet *
+ 	}
+ 	dev->net->netdev_ops = &qmi_wwan_netdev_ops;
+ 	dev->net->sysfs_groups[0] = &qmi_wwan_sysfs_attr_group;
++#if 1 //Added by Quectel
++	if (dev->udev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
++		dev_info(&intf->dev, "QuectelEC25&EC21&EG91&EG95&EG06&EP06&EM06&BG96&AG35 work on RawIP mode\n");
++		dev->net->flags |= IFF_NOARP;
++		usb_control_msg(
++		interface_to_usbdev(intf),
++		usb_sndctrlpipe(interface_to_usbdev(intf), 0),
++		0x22, //USB_CDC_REQ_SET_CONTROL_LINE_STATE
++		0x21, //USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE
++		1, //active CDC DTR
++		intf->cur_altsetting->desc.bInterfaceNumber,
++		NULL, 0, 100);
++		}
++#endif
+ err:
+ 	return status;
+ }
+@@ -535,7 +567,10 @@ static const struct driver_info	qmi_wwan
+ 	.bind		= qmi_wwan_bind,
+ 	.unbind		= qmi_wwan_unbind,
+ 	.manage_power	= qmi_wwan_manage_power,
+-	.rx_fixup       = qmi_wwan_rx_fixup,
++	#if 1 //Added by Quectel
++	.tx_fixup = qmi_wwan_tx_fixup,
++	.rx_fixup = qmi_wwan_rx_fixup,
++	#endif
+ };
+ 
+ static const struct driver_info	qmi_wwan_info_quirk_dtr = {
+@@ -569,6 +604,17 @@ static const struct driver_info	qmi_wwan
+ 	QMI_FIXED_INTF(vend, prod, 0)
+ 
+ static const struct usb_device_id products[] = {
++#if 1 //Added by Quectel
++	{ QMI_FIXED_INTF(0x05C6, 0x9003, 4) }, /* Quectel UC20 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0125, 4) }, /* Quectel EC25 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0121, 4) }, /* Quectel EC21 */
++	{ QMI_FIXED_INTF(0x05C6, 0x9215, 4) }, /* Quectel EC20 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0191, 4) }, /* Quectel EG91 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0195, 4) }, /* Quectel EG95 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0306, 4) }, /* Quectel EG06/EP06/EM06 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0296, 4) }, /* Quectel BG96 */
++	{ QMI_FIXED_INTF(0x2C7C, 0x0435, 4) }, /* Quectel AG35 */
++#endif
+ 	/* 1. CDC ECM like devices match on the control interface */
+ 	{	/* Huawei E392, E398 and possibly others sharing both device id and more... */
+ 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 1, 9),
+@@ -985,7 +1031,6 @@ static const struct usb_device_id produc
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9225)},	/* Sony Gobi 2000 Modem device (N0279, VU730) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9245)},	/* Samsung Gobi 2000 Modem device (VL176) */
+ 	{QMI_GOBI_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
+-	{QMI_GOBI_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
+ 	{QMI_FIXED_INTF(0x05c6, 0x9215, 4)},	/* Quectel EC20 Mini PCIe */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{QMI_GOBI_DEVICE(0x05c6, 0x9235)},	/* Top Global Gobi 2000 Modem device (VR306) */
+--- a/drivers/usb/serial/option.c
++++ b/drivers/usb/serial/option.c
+@@ -553,6 +553,22 @@ static void option_instat_callback(struc
+ #define WETELECOM_PRODUCT_6802			0x6802
+ #define WETELECOM_PRODUCT_WMD300		0x6803
+ 
++#define LONGSUNG_PRODUCT_U9300C                 0x9b3c
++
++/* FORGE PRODUCT */
++#define FORGE_VENDOR_ID                         0x05c6
++
++#define FORGE_PRODUCT_SLM750                    0xf601
++
++/* NODECOM PRODUCT */
++#define NODECOM_VENDOR_ID                       0x1508
++
++#define NODECOM_PRODUCT_NL660                   0x1001
++
++/* NEOWAY PRODUCT */
++#define NEOWAY_VENDOR_ID                        0x2949
++
++#define NEOWAY_PRODUCT_N720                     0x8243
+ 
+ /* Device flags */
+ 
+@@ -564,6 +580,24 @@ static void option_instat_callback(struc
+ 
+ 
+ static const struct usb_device_id option_ids[] = {
++#if 1 //Added by Quectel
++	{ USB_DEVICE(0x05C6, 0x9090) }, /* Quectel UC15 */
++	{ USB_DEVICE(0x05C6, 0x9003) }, /* Quectel UC20 */
++	{ USB_DEVICE(0x2C7C, 0x0125) }, /* Quectel EC25 */
++	{ USB_DEVICE(0x2C7C, 0x0121) }, /* Quectel EC21 */
++	{ USB_DEVICE(0x05C6, 0x9215) }, /* Quectel EC20 */
++	{ USB_DEVICE(0x2C7C, 0x0191) }, /* Quectel EG91 */
++	{ USB_DEVICE(0x2C7C, 0x0195) }, /* Quectel EG95 */
++	{ USB_DEVICE(0x2C7C, 0x0306) }, /* Quectel EG06/EP06/EM06 */
++	{ USB_DEVICE(0x2C7C, 0x0296) }, /* Quectel BG96 */
++	{ USB_DEVICE(0x2C7C, 0x0435) }, /* Quectel AG35 */
++#endif
++	{ USB_DEVICE(0x19d2, 0x0536) },/* MZ386 */
++	{ USB_DEVICE(LONGCHEER_VENDOR_ID, LONGSUNG_PRODUCT_U9300C) },
++	{ USB_DEVICE(FORGE_VENDOR_ID, FORGE_PRODUCT_SLM750) },
++	{ USB_DEVICE(NODECOM_VENDOR_ID, NODECOM_PRODUCT_NL660) },
++	{ USB_DEVICE(NEOWAY_VENDOR_ID, NEOWAY_PRODUCT_N720) },
++
+ 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
+ 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
+ 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA_LIGHT) },
+@@ -1972,6 +2006,9 @@ static struct usb_serial_driver option_1
+ #ifdef CONFIG_PM
+ 	.suspend           = usb_wwan_suspend,
+ 	.resume            = usb_wwan_resume,
++#if 1 //Added by Quectel
++	.reset_resume = usb_wwan_resume,
++#endif
+ #endif
+ };
+ 
+@@ -2005,12 +2042,67 @@ static int option_probe(struct usb_seria
+ 	 * a separate module.
+ 	 */
+ 	if (dev_desc->idVendor == cpu_to_le16(SAMSUNG_VENDOR_ID) &&
+-	    dev_desc->idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &&
+-	    iface_desc->bInterfaceClass != USB_CLASS_CDC_DATA)
++			dev_desc->idProduct == cpu_to_le16(SAMSUNG_PRODUCT_GT_B3730) &&
++			iface_desc->bInterfaceClass != USB_CLASS_CDC_DATA)
+ 		return -ENODEV;
+ 
+-	/* Store the device flags so we can use them during attach. */
+-	usb_set_serial_data(serial, (void *)device_flags);
++#if 1 //Added by Quectel
++	//Quectel UC20's interface 4 can be used as USB network device
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && \
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9003) \
++			&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
++		return -ENODEV;
++	//Quectel EC20's interface 4 can be used as USB network device
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) && \
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9215) \
++			&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
++		return -ENODEV;
++	//Quectel EC25&EC21&EG91&EG95&EG06&EP06&EM06&BG96/AG35's interface 4 can be used as USB network device
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C) \
++			&& serial->interface->cur_altsetting->desc.bInterfaceNumber >= 4)
++		return -ENODEV;
++#endif
++#if 1 //Added by Quectel
++	//For USB Auto Suspend
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9090)) {
++		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
++		usb_enable_autosuspend(serial->dev);
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9003)) {
++		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
++		usb_enable_autosuspend(serial->dev);
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)) {
++		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
++		usb_set_serial_data(serial, (void *)device_flags);
++		usb_enable_autosuspend(serial->dev);
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
++		pm_runtime_set_autosuspend_delay(&serial->dev->dev, 3000);
++		usb_enable_autosuspend(serial->dev);
++	}
++#endif
++#if 1 //Added by Quectel
++	//For USB Remote Wakeup
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9090)) {
++		device_init_wakeup(&serial->dev->dev, 1); //usb remote wakeup
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9003)) {
++		device_init_wakeup(&serial->dev->dev, 1); //usb remote wakeup
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x05C6) &&
++			serial->dev->descriptor.idProduct == cpu_to_le16(0x9215)) {
++		device_init_wakeup(&serial->dev->dev, 1); //usb remote wakeup
++	}
++	if (serial->dev->descriptor.idVendor == cpu_to_le16(0x2C7C)) {
++		device_init_wakeup(&serial->dev->dev, 1); //usb remote wakeup
++	}
++#endif
+ 
+ 	return 0;
+ }
+--- a/drivers/usb/serial/qcserial.c
++++ b/drivers/usb/serial/qcserial.c
+@@ -92,7 +92,6 @@ static const struct usb_device_id id_tab
+ 	{USB_DEVICE(0x03f0, 0x241d)},	/* HP Gobi 2000 QDL device (VP412) */
+ 	{USB_DEVICE(0x03f0, 0x251d)},	/* HP Gobi 2000 Modem device (VP412) */
+ 	{USB_DEVICE(0x05c6, 0x9214)},	/* Acer Gobi 2000 QDL device (VP413) */
+-	{USB_DEVICE(0x05c6, 0x9215)},	/* Acer Gobi 2000 Modem device (VP413) */
+ 	{USB_DEVICE(0x05c6, 0x9264)},	/* Asus Gobi 2000 QDL device (VR305) */
+ 	{USB_DEVICE(0x05c6, 0x9265)},	/* Asus Gobi 2000 Modem device (VR305) */
+ 	{USB_DEVICE(0x05c6, 0x9234)},	/* Top Global Gobi 2000 QDL device (VR306) */
+--- a/drivers/usb/serial/usb_wwan.c
++++ b/drivers/usb/serial/usb_wwan.c
+@@ -504,6 +504,19 @@ static struct urb *usb_wwan_setup_urb(st
+ 	usb_fill_bulk_urb(urb, serial->dev,
+ 			  usb_sndbulkpipe(serial->dev, endpoint) | dir,
+ 			  buf, len, callback, ctx);
++#if 1 //Added by Quectel for zero packet
++	if (dir == USB_DIR_OUT) {
++		struct usb_device_descriptor *desc = &serial->dev->descriptor;
++	if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9090))
++		urb->transfer_flags |= URB_ZERO_PACKET;
++	if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9003))
++		urb->transfer_flags |= URB_ZERO_PACKET;
++	if (desc->idVendor == cpu_to_le16(0x05C6) && desc->idProduct == cpu_to_le16(0x9215))
++		urb->transfer_flags |= URB_ZERO_PACKET;
++	if (desc->idVendor == cpu_to_le16(0x2C7C))
++		urb->transfer_flags |= URB_ZERO_PACKET;
++	}
++#endif
+ 
+ 	return urb;
+ }
diff --git a/target/linux/ar71xx/patches-4.9/821-add-QCA8337-PHY-reset.patch b/target/linux/ar71xx/patches-4.9/821-add-QCA8337-PHY-reset.patch
new file mode 100644
index 0000000..455ba58
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.9/821-add-QCA8337-PHY-reset.patch
@@ -0,0 +1,37 @@
+--- a/drivers/net/phy/ar8327.c
++++ b/drivers/net/phy/ar8327.c
+@@ -1279,6 +1279,21 @@ ar8327_sw_set_igmp_v3(struct switch_dev
+ 	return 0;
+ }
+ 
++int
++ar8xxx_hw_reset(struct switch_dev *dev,
++			      const struct switch_attr *attr,
++			      struct switch_val *val)
++{
++	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
++	int ret;
++
++	mutex_lock(&priv->reg_mutex);
++	ret = priv->chip->hw_init(priv);
++	mutex_unlock(&priv->reg_mutex);
++
++	return ret;
++}
++
+ static int
+ ar8327_sw_set_port_vlan_prio(struct switch_dev *dev, const struct switch_attr *attr,
+ 			     struct switch_val *val)
+@@ -1393,6 +1408,12 @@ static const struct switch_attr ar8327_s
+ 		.get = ar8327_sw_get_igmp_v3,
+ 		.max = 1
+ 	},
++	{
++		.type = SWITCH_TYPE_NOVAL,
++		.name = "phy_reset",
++		.description = "phy hw reset",
++		.set = ar8xxx_hw_reset,
++	},
+ };
+ 
+ static const struct switch_attr ar8327_sw_attr_port[] = {
diff --git a/target/linux/ar71xx/patches-4.9/931-support-fast-forward.patch b/target/linux/ar71xx/patches-4.9/931-support-fast-forward.patch
new file mode 100644
index 0000000..a9473fe
--- /dev/null
+++ b/target/linux/ar71xx/patches-4.9/931-support-fast-forward.patch
@@ -0,0 +1,100 @@
+--- a/include/linux/skbuff.h
++++ b/include/linux/skbuff.h
+@@ -738,6 +738,7 @@ struct sk_buff {
+ #endif
+ 	__u8			ipvs_property:1;
+ 	__u8			inner_protocol_type:1;
++	__u8			fast_forwarded:1;
+ 	__u8			remcsum_offload:1;
+ #ifdef CONFIG_NET_SWITCHDEV
+ 	__u8			offload_fwd_mark:1;
+--- a/net/core/dev.c
++++ b/net/core/dev.c
+@@ -2947,8 +2947,14 @@ static int xmit_one(struct sk_buff *skb,
+ 	unsigned int len;
+ 	int rc;
+ 
+-	if (!list_empty(&ptype_all) || !list_empty(&dev->ptype_all))
+-		dev_queue_xmit_nit(skb, dev);
++	/*
++	 * If this skb has been fast forwarded then we don't want it to
++	 * go to any taps (by definition we're trying to bypass them).
++	 */
++	if (!skb->fast_forwarded) {
++		if (!list_empty(&ptype_all))
++			dev_queue_xmit_nit(skb, dev);
++	}
+ 
+ #ifdef CONFIG_ETHERNET_PACKET_MANGLE
+ 	if (!dev->eth_mangle_tx ||
+@@ -4137,6 +4143,9 @@ static inline int nf_ingress(struct sk_b
+ 	return 0;
+ }
+ 
++int (*fast_nat_recv)(struct sk_buff *skb) __rcu __read_mostly;
++EXPORT_SYMBOL_GPL(fast_nat_recv);
++
+ static int __netif_receive_skb_core(struct sk_buff *skb, bool pfmemalloc)
+ {
+ 	struct packet_type *ptype, *pt_prev;
+@@ -4146,6 +4155,8 @@ static int __netif_receive_skb_core(stru
+ 	int ret = NET_RX_DROP;
+ 	__be16 type;
+ 
++	int (*fast_recv)(struct sk_buff *skb);
++
+ 	net_timestamp_check(!netdev_tstamp_prequeue, skb);
+ 
+ 	trace_netif_receive_skb(skb);
+@@ -4171,6 +4182,12 @@ another_round:
+ 			goto out;
+ 	}
+ 
++	fast_recv = rcu_dereference(fast_nat_recv);
++	if (fast_recv && fast_recv(skb)) {
++		ret = NET_RX_SUCCESS;
++		goto out;
++	}
++
+ #ifdef CONFIG_NET_CLS_ACT
+ 	if (skb->tc_verd & TC_NCLS) {
+ 		skb->tc_verd = CLR_TC_NCLS(skb->tc_verd);
+--- a/net/netfilter/nf_conntrack_proto_tcp.c
++++ b/net/netfilter/nf_conntrack_proto_tcp.c
+@@ -35,6 +35,7 @@
+ 
+ /* Do not check the TCP window for incoming packets  */
+ static int nf_ct_tcp_no_window_check __read_mostly = 1;
++EXPORT_SYMBOL_GPL(nf_ct_tcp_no_window_check);
+ 
+ /* "Be conservative in what you do,
+     be liberal in what you accept from others."
+--- a/net/bridge/br_if.c
++++ b/net/bridge/br_if.c
+@@ -655,3 +655,26 @@ void br_port_flags_change(struct net_bri
+ 	if (mask & BR_AUTO_MASK)
+ 		nbp_update_port_count(br);
+ }
++/* Update bridge statistics for bridge packets processed by offload engines */
++void br_dev_update_stats(struct net_device *dev, struct rtnl_link_stats64 *nlstats)
++{
++	struct net_bridge *br;
++	struct pcpu_sw_netstats *stats;
++
++	/*
++	 * Is this a bridge?
++	 */
++	if (!(dev->priv_flags & IFF_EBRIDGE))
++		return;
++
++	br = netdev_priv(dev);
++	stats = per_cpu_ptr(br->stats, 0);
++
++	u64_stats_update_begin(&stats->syncp);
++	stats->rx_packets += nlstats->rx_packets;
++	stats->rx_bytes += nlstats->rx_bytes;
++	stats->tx_packets += nlstats->tx_packets;
++	stats->tx_bytes += nlstats->tx_bytes;
++	u64_stats_update_end(&stats->syncp);
++}
++EXPORT_SYMBOL_GPL(br_dev_update_stats);
diff --git a/target/linux/generic/hack-4.14/801-wireless_compatible_with_deprecated_wext_api.patch b/target/linux/generic/hack-4.14/801-wireless_compatible_with_deprecated_wext_api.patch
new file mode 100644
index 0000000..f900788
--- /dev/null
+++ b/target/linux/generic/hack-4.14/801-wireless_compatible_with_deprecated_wext_api.patch
@@ -0,0 +1,15 @@
+--- a/net/wireless/wext-core.c
++++ b/net/wireless/wext-core.c
+@@ -956,6 +956,12 @@ static int wireless_process_ioctl(struct
+ 		else if (private)
+ 			return private(dev, iwr, cmd, info, handler);
+ 	}
++
++	/* Old driver API : call ioctl handler */
++	if (dev->netdev_ops->ndo_do_ioctl) {
++		return dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq *)iwr, cmd);
++	}
++
+ 	return -EOPNOTSUPP;
+ }
+ 
diff --git a/target/linux/ramips/base-files/etc/board.d/01_leds b/target/linux/ramips/base-files/etc/board.d/01_leds
index 54504c6..afce079 100755
--- a/target/linux/ramips/base-files/etc/board.d/01_leds
+++ b/target/linux/ramips/base-files/etc/board.d/01_leds
@@ -211,6 +211,9 @@ gl-mt750)
 gl-mt300n-v2)
 	set_wifi_led "$boardname:red:wlan"
 	;;
+vixmini)
+	set_wifi_led "$boardname:white:wlan"
+	;;
 hc5661|\
 hc5661a)
 	ucidef_set_led_default "system" "system" "$boardname:blue:system" "1"
diff --git a/target/linux/ramips/base-files/etc/board.d/02_network b/target/linux/ramips/base-files/etc/board.d/02_network
index 76b6fe9..e3ebd99 100755
--- a/target/linux/ramips/base-files/etc/board.d/02_network
+++ b/target/linux/ramips/base-files/etc/board.d/02_network
@@ -241,6 +241,9 @@ ramips_setup_interfaces()
 		ucidef_add_switch "switch0" \
 			"1:lan" "0:wan" "6@eth0"
 		;;
+	vixmini)
+		ucidef_set_interface_lan "eth0"
+		;;
 	awapn2403)
 		ucidef_add_switch "switch0" \
 			"0:lan" "1:wan" "6@eth0"
diff --git a/target/linux/ramips/base-files/etc/diag.sh b/target/linux/ramips/base-files/etc/diag.sh
index 2f51add..c5b39ad 100644
--- a/target/linux/ramips/base-files/etc/diag.sh
+++ b/target/linux/ramips/base-files/etc/diag.sh
@@ -201,9 +201,6 @@ get_status_led() {
 	m2m)
 		status_led="$boardname:blue:wifi"
 		;;
-	gl-mt300n-v2)
-		status_led="$boardname:green:power"
-		;;
 	m4-4M|\
 	m4-8M)
 		status_led="m4:blue:status"
diff --git a/target/linux/ramips/base-files/lib/ramips.sh b/target/linux/ramips/base-files/lib/ramips.sh
index 5741cbd..707b299 100755
--- a/target/linux/ramips/base-files/lib/ramips.sh
+++ b/target/linux/ramips/base-files/lib/ramips.sh
@@ -217,6 +217,9 @@ ramips_board_detect() {
 	*"GL-MT300N-V2")
 		name="gl-mt300n-v2"
 		;;
+	*"VIXMINI")
+		name="vixmini"
+		;;
 	*"HC5661")
 		name="hc5661"
 		;;
diff --git a/target/linux/ramips/base-files/lib/upgrade/platform.sh b/target/linux/ramips/base-files/lib/upgrade/platform.sh
index ffdc5e7..9e85975 100755
--- a/target/linux/ramips/base-files/lib/upgrade/platform.sh
+++ b/target/linux/ramips/base-files/lib/upgrade/platform.sh
@@ -69,6 +69,7 @@ platform_check_image() {
 	gl-mt300n|\
 	gl-mt750|\
 	gl-mt300n-v2|\
+	vixmini|\
 	hc5*61|\
 	hc5661a|\
 	hg255d|\
diff --git a/target/linux/ramips/dts/VIXMINI.dts b/target/linux/ramips/dts/VIXMINI.dts
new file mode 100644
index 0000000..b325497
--- /dev/null
+++ b/target/linux/ramips/dts/VIXMINI.dts
@@ -0,0 +1,106 @@
+/dts-v1/;
+
+#include "mt7628an.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/input/input.h>
+
+/{
+	compatible = "glinet,vixmini", "mediatek,mt7628an-soc";
+	model = "VIXMINI";
+
+	chosen {
+		bootargs = "console=ttyS0,115200";
+	};
+
+	memory@0 {
+		device_type = "memory";
+		reg = <0x0 0x4000000>;
+	};
+
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		power {
+			label = "vixmini:blue:power";
+			default-state = "on";
+			gpios = <&gpio1 10 GPIO_ACTIVE_LOW>;
+		};
+
+		wlan {
+			label = "vixmini:white:wlan";
+			gpios = <&gpio1 12 GPIO_ACTIVE_LOW>;
+		};
+	};
+
+	gpio-keys-polled {
+		compatible = "gpio-keys-polled";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		poll-interval = <20>;
+
+		reset {
+			label = "reset";
+			gpios = <&gpio1 6 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_RESTART>;
+		};
+	};
+};
+
+&pinctrl {
+	state_default: pinctrl0 {
+		gpio {
+			ralink,group = "wdt", "wled_an", "p1led_an";
+			ralink,function = "gpio";
+		};
+	};
+};
+
+&ethernet {
+	mtd-mac-address = <&factory 0x4>;
+};
+
+&wmac {
+	status = "okay";
+	ralink,mtd-eeprom = <&factory 0x4>;
+};
+
+&spi0 {
+	status = "okay";
+
+	m25p80@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <10000000>;
+		m25p,chunked-io = <32>;
+
+		partition@0 {
+			label = "u-boot";
+			reg = <0x0 0x30000>;
+			read-only;
+		};
+
+		partition@30000 {
+			label = "u-boot-env";
+			reg = <0x30000 0x10000>;
+			read-only;
+		};
+
+		factory: partition@40000 {
+			 label = "factory";
+			 reg = <0x40000 0x10000>;
+			 read-only;
+		};
+
+		partition@50000 {
+			 label = "firmware";
+			 reg = <0x50000 0x1fb0000>;
+		};
+	};
+};
+
+&uart1 {
+	status = "okay";
+};
diff --git a/target/linux/ramips/image/mt76x8.mk b/target/linux/ramips/image/mt76x8.mk
index 21c5357..e6c8aed 100644
--- a/target/linux/ramips/image/mt76x8.mk
+++ b/target/linux/ramips/image/mt76x8.mk
@@ -50,6 +50,13 @@ define Device/gl-mt300n-v2
 endef
 TARGET_DEVICES += gl-mt300n-v2
 
+define Device/vixmini
+  DTS := VIXMINI
+  IMAGE_SIZE := $(ralink_default_fw_size_8M)
+  DEVICE_TITLE := GL-iNet VIXMINI
+endef
+TARGET_DEVICES += vixmini
+
 define Device/hc5661a
   DTS := HC5661A
   IMAGE_SIZE := $(ralink_default_fw_size_16M)
diff --git a/target/linux/ramips/mt7620/config-4.14 b/target/linux/ramips/mt7620/config-4.14
index d60696b..4b2f050 100644
--- a/target/linux/ramips/mt7620/config-4.14
+++ b/target/linux/ramips/mt7620/config-4.14
@@ -155,8 +155,7 @@ CONFIG_MTD_CMDLINE_PARTS=y
 CONFIG_MTD_M25P80=y
 CONFIG_MTD_PHYSMAP=y
 CONFIG_MTD_SPI_NOR=y
-CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
-CONFIG_MTD_SPI_NOR_USE_4K_SECTORS_LIMIT=16384
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
 CONFIG_MTD_SPLIT_FIRMWARE=y
 CONFIG_MTD_SPLIT_JIMAGE_FW=y
 CONFIG_MTD_SPLIT_SEAMA_FW=y
diff --git a/target/linux/ramips/mt76x8/config-4.4 b/target/linux/ramips/mt76x8/config-4.4
new file mode 100644
index 0000000..6b04457
--- /dev/null
+++ b/target/linux/ramips/mt76x8/config-4.4
@@ -0,0 +1,206 @@
+CONFIG_ARCH_BINFMT_ELF_STATE=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+# CONFIG_ARCH_HAS_GCOV_PROFILE_ALL is not set
+CONFIG_ARCH_HAS_RESET_CONTROLLER=y
+# CONFIG_ARCH_HAS_SG_CHAIN is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+CONFIG_ARCH_MIGHT_HAVE_PC_SERIO=y
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_AT803X_PHY=y
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_CEVT_R4K=y
+CONFIG_CEVT_SYSTICK_QUIRK=y
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_CLKEVT_RT3352=y
+CONFIG_CLKSRC_MMIO=y
+CONFIG_CLKSRC_OF=y
+CONFIG_CLKSRC_PROBE=y
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_CMDLINE="rootfstype=squashfs,jffs2"
+CONFIG_CMDLINE_BOOL=y
+# CONFIG_CMDLINE_OVERRIDE is not set
+CONFIG_CPU_GENERIC_DUMP_TLB=y
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_SYNC=y
+CONFIG_CPU_LITTLE_ENDIAN=y
+CONFIG_CPU_MIPS32=y
+# CONFIG_CPU_MIPS32_R1 is not set
+CONFIG_CPU_MIPS32_R2=y
+CONFIG_CPU_MIPSR2=y
+CONFIG_CPU_NEEDS_NO_SMARTMIPS_OR_MICROMIPS=y
+CONFIG_CPU_R4K_CACHE_TLB=y
+CONFIG_CPU_R4K_FPU=y
+CONFIG_CPU_SUPPORTS_32BIT_KERNEL=y
+CONFIG_CPU_SUPPORTS_HIGHMEM=y
+CONFIG_CPU_SUPPORTS_MSA=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+CONFIG_CSRC_R4K=y
+CONFIG_DEBUG_PINCTRL=y
+CONFIG_DMA_NONCOHERENT=y
+# CONFIG_DTB_MT7620A_EVAL is not set
+CONFIG_DTB_RT_NONE=y
+CONFIG_DTC=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_GENERIC_ATOMIC64=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_GENERIC_IO=y
+CONFIG_GENERIC_IRQ_CHIP=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_PHY=y
+CONFIG_GENERIC_SCHED_CLOCK=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+CONFIG_GPIO_MT7621=y
+# CONFIG_GPIO_RALINK is not set
+CONFIG_GPIO_SYSFS=y
+CONFIG_HARDWARE_WATCHPOINTS=y
+CONFIG_HAS_DMA=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT_MAP=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+# CONFIG_HAVE_ARCH_BITREVERSE is not set
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+CONFIG_HAVE_BPF_JIT=y
+CONFIG_HAVE_CC_STACKPROTECTOR=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_HAVE_IDE=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_KVM=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_HAVE_MACH_CLKDEV=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_HAVE_NET_DSA=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HW_HAS_PCI=y
+CONFIG_HZ_PERIODIC=y
+CONFIG_ICPLUS_PHY=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IRQCHIP=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_IRQ_INTC=y
+CONFIG_IRQ_MIPS_CPU=y
+CONFIG_IRQ_WORK=y
+CONFIG_LIBFDT=y
+CONFIG_MDIO_BOARDINFO=y
+CONFIG_MIPS=y
+CONFIG_MIPS_CLOCK_VSYSCALL=y
+# CONFIG_MIPS_CMDLINE_DTB_EXTEND is not set
+# CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER is not set
+CONFIG_MIPS_CMDLINE_FROM_DTB=y
+# CONFIG_MIPS_ELF_APPENDED_DTB is not set
+# CONFIG_MIPS_HUGE_TLB_SUPPORT is not set
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+# CONFIG_MIPS_MACHINE is not set
+CONFIG_MIPS_NO_APPENDED_DTB=y
+# CONFIG_MIPS_RAW_APPENDED_DTB is not set
+CONFIG_MIPS_SPRAM=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_MT7621_WDT=y
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_M25P80=y
+CONFIG_MTD_NAND_MT7620=y
+CONFIG_MTD_PHYSMAP=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_MTD_SPLIT_FIRMWARE=y
+CONFIG_MTD_SPLIT_UIMAGE_FW=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_NET_MEDIATEK_ESW_RT3050=y
+# CONFIG_NET_MEDIATEK_MT7620 is not set
+CONFIG_NET_MEDIATEK_RT3050=y
+CONFIG_NET_MEDIATEK_SOC=y
+CONFIG_NET_VENDOR_MEDIATEK=y
+CONFIG_NO_GENERIC_PCI_IOPORT_MAP=y
+# CONFIG_NO_IOPORT_MAP is not set
+CONFIG_OF=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_ADDRESS_PCI=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_GPIO=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_MTD=y
+CONFIG_OF_NET=y
+CONFIG_OF_PCI=y
+CONFIG_OF_PCI_IRQ=y
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PERF_USE_VMALLOC=y
+CONFIG_PGTABLE_LEVELS=2
+CONFIG_PHYLIB=y
+CONFIG_PHY_RALINK_USB=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_RT2880=y
+# CONFIG_PINCTRL_SINGLE is not set
+CONFIG_RALINK=y
+# CONFIG_RALINK_WDT is not set
+# CONFIG_RCU_STALL_COMMON is not set
+CONFIG_RESET_CONTROLLER=y
+CONFIG_SCHED_HRTICK=y
+# CONFIG_SCHED_INFO is not set
+# CONFIG_SCSI_DMA is not set
+# CONFIG_SERIAL_8250_FSL is not set
+CONFIG_SERIAL_8250_NR_UARTS=3
+CONFIG_SERIAL_8250_RUNTIME_UARTS=3
+CONFIG_SERIAL_OF_PLATFORM=y
+CONFIG_SOC_MT7620=y
+# CONFIG_SOC_MT7621 is not set
+# CONFIG_SOC_RT288X is not set
+# CONFIG_SOC_RT305X is not set
+# CONFIG_SOC_RT3883 is not set
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MT7621=y
+# CONFIG_SPI_RT2880 is not set
+CONFIG_SRCU=y
+CONFIG_SWCONFIG=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_SYS_HAS_CPU_MIPS32_R1=y
+CONFIG_SYS_HAS_CPU_MIPS32_R2=y
+CONFIG_SYS_HAS_EARLY_PRINTK=y
+CONFIG_SYS_SUPPORTS_32BIT_KERNEL=y
+CONFIG_SYS_SUPPORTS_ARBIT_HZ=y
+CONFIG_SYS_SUPPORTS_LITTLE_ENDIAN=y
+CONFIG_SYS_SUPPORTS_MIPS16=y
+CONFIG_TICK_CPU_ACCOUNTING=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USE_OF=y
+CONFIG_WATCHDOG_CORE=y
+CONFIG_ZONE_DMA_FLAG=0
-- 
2.7.4

